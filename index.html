<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Rectangle Partitions — SVG UI (aligned fills)</title>
<style>
  :root { --bg:#0b0d10; --ui:#11151a; --ink:#e8eef6; --muted:#aeb6c2; --accent:#56a0ff; --accent2:#ffa756; }
  *{box-sizing:border-box}
  body{margin:0;background:var(--bg);color:var(--ink);font-family:system-ui,-apple-system,Inter,Roboto,Arial,sans-serif}
  header{padding:14px 18px;background:var(--ui);position:sticky;top:0;z-index:2;border-bottom:1px solid #1c222a}
  header h1{margin:0;font-size:16px;font-weight:600}
  .wrap{display:grid;grid-template-columns:300px 1fr;gap:14px;padding:14px}
  @media (max-width: 900px){ .wrap{grid-template-columns:1fr} }
  .panel{background:var(--ui);border:1px solid #1c222a;border-radius:12px;padding:12px}
  .panel h2{margin:0 0 8px 0;font-size:14px;color:var(--muted);font-weight:600}
  .row{display:grid;grid-template-columns:1fr 130px;gap:8px;align-items:center;margin:8px 0}
  label{font-size:13px}
  input[type="number"], select{
    width:100%;background:#0f1318;color:var(--ink);
    border:1px solid #1c222a;border-radius:8px;padding:8px 10px;font-size:14px;
  }
  .btns{display:flex;gap:8px;flex-wrap:wrap;margin-top:8px}
  button{
    background:#19202a;color:var(--ink);border:1px solid #263043;border-radius:10px;
    padding:9px 12px;font-size:14px;cursor:pointer
  }
  button:hover{border-color:#36507a}
  #equation{font-variant-numeric:tabular-nums;line-height:1.35;background:#0f1318;border:1px solid #1c222a;border-radius:10px;padding:10px;margin-top:8px}
  .note{color:var(--muted);font-size:12px;margin-top:8px}
  .canvasWrap{position:relative;overflow:auto;background:#0a0d11;border:1px solid #1c222a;border-radius:12px;height:72vh;min-height:420px}
  svg{display:block}
  .legend{display:flex;gap:10px;align-items:center;font-size:12px;color:var(--muted);margin-top:6px}
  .swatch{width:14px;height:14px;border-radius:3px;display:inline-block;border:1px solid #0004}
  .toggle{
    display:inline-flex;align-items:center;gap:8px;background:#19202a;border:1px solid #263043;border-radius:999px;
    padding:6px 10px;cursor:pointer;user-select:none
  }
  .toggle input{appearance:none;width:22px;height:22px;border-radius:999px;border:1px solid #36507a;background:#0f1318;display:inline-block;position:relative}
  .toggle input:checked{background:#2c82ff}
  .dimmed{opacity:0.55;pointer-events:none}
  .panelHead{display:flex;align-items:center;justify-content:space-between;gap:8px;margin-bottom:8px}
  .panelHead h2{margin:0;font-size:14px;color:var(--muted);font-weight:600}
  .collapser{background:#19202a;color:var(--ink);border:1px solid #263043;border-radius:8px;padding:6px 10px;font-size:12px;cursor:pointer}
  .collapser:hover{border-color:#36507a}
  .panel.collapsed #controlsBody{display:none}
</style>
</head>
<body>
<header><h1>Rectangle Partitions — Toggle & Drag</h1></header>

<div class="wrap">
  <div class="panel">
    <div class="panelHead"><h2>Controls</h2><button id="collapseControls" class="collapser" aria-expanded="true" aria-controls="controlsBody" title="Collapse/expand controls">Hide</button></div>
    <div id="controlsBody">
      <div class="row">
      <label>Dots across (columns)</label><input id="gridCols" type="number" min="5" max="60" value="20">
    </div>
    <div class="row">
      <label>Dots down (rows)</label><input id="gridRows" type="number" min="5" max="60" value="20">
    </div>

    <div class="row" style="grid-template-columns:1fr auto">
      <label>Partition</label>
      <label class="toggle">
        <span id="partLabel">OFF</span>
        <input id="partToggle" type="checkbox" />
      </label>
    </div>

    <div id="splitControls">
      <div class="row">
        <label>Split direction</label>
        <select id="splitDir">
          <option value="vertical">Vertical (split columns)</option>
          <option value="horizontal">Horizontal (split rows)</option>
        </select>
      </div>
      <div class="row">
        <label>Split at</label>
        <input id="splitAt" type="number" min="0" value="6">
      </div>
    </div>

    <div class="btns">
      <button id="example">Example 6×7 → 6+1</button>
      <button id="reset">Reset</button>
      <button id="export">Export PNG</button>
    </div>

    <div id="equation" aria-live="polite"></div>
    <div class="legend">
      <span class="swatch" style="background:#ffffff; border:1px solid #1c222a"></span> Dots
      <span class="kbd">Drag empty grid: new rect</span>
      <span class="kbd">Click rect: select</span>
      <span class="kbd">Drag selected: move</span>
      <span class="kbd">Shift+drag inside: add partition (auto H/V)</span>
      <span class="kbd">Drag line: move partition</span>
      <span class="kbd">Ctrl+click line: delete partition</span>
    </div>
    <div class="note">
      Tip: <b>Drag from one dot to another</b> to draw a rectangle. <b>Drag inside</b> to move it. When partition is ON, <b>drag the split line</b> to adjust it.
    </div>
  </div>
  </div>

  <div class="panel canvasWrap">
    <svg id="board" xmlns="http://www.w3.org/2000/svg" role="img" aria-label="Dot grid with draggable rectangle and optional partition"></svg>
  </div>
</div>

<script>
(function(){
  // --- State ---
  let dotSpacing = 28, pad = 30;
  let cols = 20, rows = 20;
  let nextId = 1;
  // rect: {id,x,y,w,h, splits:{v:number[], h:number[]}, colors:{border}}
  const rects = [];
  let selectedId = null;
  let dragMode = null, dragData = null; // 'new','move','splitV','splitH'

  // --- DOM ---
  const svg = document.getElementById('board');
  const gridCols = document.getElementById('gridCols');
  const gridRows = document.getElementById('gridRows');
  const dotSpacingCtl = document.getElementById('dotSpacingCtl');
  const hcToggle = document.getElementById('hcToggle');
  const hcLabel = document.getElementById('hcLabel');

  const rWctl = document.getElementById('rW');
  const rHctl = document.getElementById('rH');
  const rectIdCtl = document.getElementById('rectId');
  const splitControls = document.getElementById('splitControls');
  const fmtSel    = document.getElementById('fmt');
  const equation  = document.getElementById('equation');

  const colA = document.getElementById('colA');
  const colB = document.getElementById('colB');
  const colBorder = document.getElementById('colBorder');

  const btnExample= document.getElementById('example');
  const btnReset  = document.getElementById('reset');
  const btnDelete = document.getElementById('delete');
  const btnExport = document.getElementById('export');

  // --- Helpers ---
  const clamp = (v,min,max)=>Math.max(min,Math.min(max,v));
  const byId = id => rects.find(r=>r.id===id) || null;
  const sel = ()=> byId(selectedId);
  const snapGrid = (x,y)=>({ c: clamp(Math.round((x - pad)/dotSpacing), 0, cols-1),
                              r: clamp(Math.round((y - pad)/dotSpacing), 0, rows-1) });
  const sizeSVG = ()=>{ const w = pad*2 + (cols-1)*dotSpacing, h = pad*2 + (rows-1)*dotSpacing; svg.setAttribute('viewBox',`0 0 ${w} ${h}`); svg.setAttribute('width',w); svg.setAttribute('height',h); };
  const insideRect = (R,c,rr)=> c>=R.x && c<=R.x+(R.w-1) && rr>=R.y && rr<=R.y+(R.h-1);
  const getStrokeWidth = ()=> hcToggle && hcToggle.checked? 3.2 : 2.4;
  const getSplitWidth  = ()=> hcToggle && hcToggle.checked? 3.0 : 2.2;
  const getDotRadius   = ()=> hcToggle && hcToggle.checked? 3.6 : 2.8;

  function uniqSorted(arr, max){
    const set = new Set(arr.filter(n=>Number.isInteger(n) && n>0 && n<max));
    return Array.from(set).sort((a,b)=>a-b);
  }

  // --- Drawing ---
  function draw(){
    cols = clamp(+gridCols.value,5,60);
    rows = clamp(+gridRows.value,5,60);
    if (dotSpacingCtl) dotSpacing = clamp(+dotSpacingCtl.value || 28,16,60);

    sizeSVG(); while(svg.firstChild) svg.removeChild(svg.firstChild);

    // Dots
    const dotGroup = document.createElementNS('http://www.w3.org/2000/svg','g');
    for(let rr=0; rr<rows; rr++){
      for(let cc=0; cc<cols; cc++){
        const cx = pad + cc*dotSpacing, cy = pad + rr*dotSpacing;
        const dot = document.createElementNS('http://www.w3.org/2000/svg','circle');
        dot.setAttribute('cx', cx); dot.setAttribute('cy', cy);
        dot.setAttribute('r', getDotRadius()); dot.setAttribute('fill', '#ffffff');
        dotGroup.appendChild(dot);
      }
    }
    svg.appendChild(dotGroup);

    // Rects + partitions
    rects.forEach(R=>{
      const leftX = pad + R.x*dotSpacing;
      const rightX= pad + (R.x + (R.w-1))*dotSpacing;
      const topY  = pad + R.y*dotSpacing;
      const botY  = pad + (R.y + (R.h-1))*dotSpacing;

      // partition lines
      (R.splits.v||[]).forEach(at=>{
        const x = pad + (R.x + at)*dotSpacing;
        const line = document.createElementNS('http://www.w3.org/2000/svg','line');
        line.setAttribute('x1', x); line.setAttribute('x2', x);
        line.setAttribute('y1', topY); line.setAttribute('y2', botY);
        line.setAttribute('stroke', '#ffd7a8');
        line.setAttribute('stroke-width', getSplitWidth());
        line.dataset.rect = R.id; line.dataset.dir='v'; line.dataset.at=at;
        svg.appendChild(line);
      });
      (R.splits.h||[]).forEach(at=>{
        const y = pad + (R.y + at)*dotSpacing;
        const line = document.createElementNS('http://www.w3.org/2000/svg','line');
        line.setAttribute('x1', leftX); line.setAttribute('x2', rightX);
        line.setAttribute('y1', y); line.setAttribute('y2', y);
        line.setAttribute('stroke', '#ffd7a8');
        line.setAttribute('stroke-width', getSplitWidth());
        line.dataset.rect = R.id; line.dataset.dir='h'; line.dataset.at=at;
        svg.appendChild(line);
      });

      // border
      const br = document.createElementNS('http://www.w3.org/2000/svg','rect');
      br.setAttribute('x', leftX); br.setAttribute('y', topY);
      br.setAttribute('width', (R.w-1)*dotSpacing);
      br.setAttribute('height',(R.h-1)*dotSpacing);
      br.setAttribute('fill','none');
      br.setAttribute('stroke', (R.colors && R.colors.border) || (colBorder? colBorder.value : '#56a0ff'));
      br.setAttribute('stroke-width', selectedId===R.id? getStrokeWidth()*1.35 : getStrokeWidth());
      svg.appendChild(br);

      addLabels(R);
    });

    refreshControls();
    updateEquation();
  }

  function segmentLabelsPositions(start, len, splits){
    // return [{midPx, length}] positions for label centers along axis
    const pts = [0, ...splits, len];
    const out = [];
    for(let i=0;i<pts.length-1;i++){
      const a = pts[i], b = pts[i+1];
      out.push({a, b, length: b-a, mid: (a+b)/2});
    }
    return out;
  }

  function addLabels(R){
    const g = document.createElementNS('http://www.w3.org/2000/svg','g');
    g.setAttribute('font-size','12'); g.setAttribute('fill','#e8eef6');

    const leftX = pad + R.x*dotSpacing;
    const rightX= pad + (R.x + (R.w-1))*dotSpacing;
    const topY  = pad + R.y*dotSpacing;
    const botY  = pad + (R.y + (R.h-1))*dotSpacing;

    // Width labels: if splits present, show only segment lengths; else show full width
    const vSplits = uniqSorted(R.splits.v||[], R.w);
    const hSplits = uniqSorted(R.splits.h||[], R.h);

    const wSegs = segmentLabelsPositions(0, R.w, vSplits);
    const hSegs = segmentLabelsPositions(0, R.h, hSplits);

    const topYLabel = Math.max(12, topY - 10);
    wSegs.forEach(seg=>{
      const x = pad + (R.x + seg.mid)*dotSpacing;
      const t = document.createElementNS('http://www.w3.org/2000/svg','text');
      t.setAttribute('x', x); t.setAttribute('y', topYLabel);
      t.setAttribute('text-anchor','middle'); t.textContent = `${seg.length}`; g.appendChild(t);
    });

    const leftXLabel = Math.max(10, leftX - 10);
    hSegs.forEach(seg=>{
      const y = pad + (R.y + seg.mid)*dotSpacing + 4;
      const t = document.createElementNS('http://www.w3.org/2000/svg','text');
      t.setAttribute('x', leftXLabel); t.setAttribute('y', y);
      t.setAttribute('text-anchor','middle'); t.textContent = `${seg.length}`; g.appendChild(t);
    });

    svg.appendChild(g);
  }

  // --- Equation / live counts ---
  function updateEquation(){
    const R = sel();
    if(!R){ equation.innerHTML = '<i>No rectangle selected. Drag on the grid to create one, or click a rectangle to select.</i>'; return; }
    const total = R.w * R.h;
    const v = uniqSorted(R.splits.v||[], R.w), h = uniqSorted(R.splits.h||[], R.h);
    const wSegs = segmentLabelsPositions(0,R.w,v).map(s=>s.length);
    const hSegs = segmentLabelsPositions(0,R.h,h).map(s=>s.length);

    let html = `<div><b>Selected #${R.id}</b> — area <b>${total}</b></div>`;
    html += `<div>Width segments: [${wSegs.join(' + ')}] = ${wSegs.reduce((a,b)=>a+b,0)}</div>`;
    html += `<div>Height segments: [${hSegs.join(' + ')}] = ${hSegs.reduce((a,b)=>a+b,0)}</div>`;
    if (fmtSel && fmtSel.value==='expanded' && wSegs.length && hSegs.length){
      const products = [];
      hSegs.forEach(hr=> wSegs.forEach(wc=> products.push(hr*wc)));
      html += `<div>Tiles: ${products.join(' + ')} = <b>${products.reduce((a,b)=>a+b,0)}</b></div>`;
    }
    equation.innerHTML = html;
  }

  // --- Interaction ---
  function svgPointFromEvent(e){ const pt = svg.createSVGPoint(); pt.x = e.clientX; pt.y = e.clientY; return pt.matrixTransform(svg.getScreenCTM().inverse()); }
  function rectAt(c,r){ return rects.slice().reverse().find(R=>insideRect(R,c,r)) || null; }

  function nearestSplit(R, p){
    // Return {dir, index} if near a split line, else null
    const tol = 8;
    const leftX = pad + R.x*dotSpacing;
    const rightX= pad + (R.x + (R.w-1))*dotSpacing;
    const topY  = pad + R.y*dotSpacing;
    const botY  = pad + (R.y + (R.h-1))*dotSpacing;
    // vertical
    for(let i=0;i<(R.splits.v||[]).length;i++){
      const at = R.splits.v[i]; const x = pad + (R.x + at)*dotSpacing;
      if (Math.abs(p.x - x) <= tol && p.y >= topY && p.y <= botY) return {dir:'v', index:i};
    }
    for(let i=0;i<(R.splits.h||[]).length;i++){
      const at = R.splits.h[i]; const y = pad + (R.y + at)*dotSpacing;
      if (Math.abs(p.y - y) <= tol && p.x >= leftX && p.x <= rightX) return {dir:'h', index:i};
    }
    return null;
  }

  svg.addEventListener('pointerdown', (e)=>{
    const p = svgPointFromEvent(e), g = snapGrid(p.x, p.y);
    const R = rectAt(g.c, g.r);
    if(R){
      selectedId = R.id; refreshControls();

      // Delete split with Ctrl+click
      const near = nearestSplit(R, p);
      if (near && (e.ctrlKey || e.metaKey)){
        if (near.dir==='v') R.splits.v.splice(near.index,1);
        else R.splits.h.splice(near.index,1);
        draw(); return;
      }

      // Move existing split if grabbed
      if (near){
        dragMode = (near.dir==='v') ? 'splitV' : 'splitH';
        dragData = { rectId:R.id, index:near.index };
        svg.setPointerCapture(e.pointerId); return;
      }

      // Shift+drag to create new split, otherwise move rect
      if(e.shiftKey){
        dragMode='newSplit'; dragData={ rectId:R.id, start:g };
        svg.setPointerCapture(e.pointerId); return;
      }

      dragMode='move'; dragData={ rectId:R.id, startC:g.c, startR:g.r, startX:R.x, startY:R.y };
      svg.setPointerCapture(e.pointerId);
    } else {
      // start a new rectangle
      dragMode='new'; dragData={ startC:g.c, startR:g.r };
      svg.setPointerCapture(e.pointerId);
    }
  });

  svg.addEventListener('pointermove', (e)=>{
    if(!dragMode) return;
    const p = svgPointFromEvent(e), g = snapGrid(p.x, p.y);
    if(dragMode==='new'){
      const minC=Math.min(dragData.startC,g.c), maxC=Math.max(dragData.startC,g.c);
      const minR=Math.min(dragData.startR,g.r), maxR=Math.max(dragData.startR,g.r);
      if(!dragData.tempId){
        const id = nextId++;
        const R = {id, x:minC, y:minR, w:(maxC-minC)+1, h:(maxR-minR)+1, splits:{v:[],h:[]}, colors:{border: (colBorder? colBorder.value : '#56a0ff')}};
        rects.push(R); selectedId=id; dragData.tempId=id;
      } else {
        const R = byId(dragData.tempId);
        R.x=minC; R.y=minR; R.w=(maxC-minC)+1; R.h=(maxR-minR)+1;
      }
      draw();
    } else if(dragMode==='move'){
      const R = byId(dragData.rectId); if(!R) return;
      const dC=g.c-dragData.startC, dR=g.r-dragData.startR;
      R.x = clamp(dragData.startX + dC, 0, cols - R.w);
      R.y = clamp(dragData.startY + dR, 0, rows - R.h);
      draw();
    } else if(dragMode==='splitV'){
      const R = byId(dragData.rectId); if(!R) return;
      R.splits.v[dragData.index] = clamp(g.c - R.x, 1, R.w-1);
      R.splits.v = uniqSorted(R.splits.v, R.w); draw();
    } else if(dragMode==='splitH'){
      const R = byId(dragData.rectId); if(!R) return;
      R.splits.h[dragData.index] = clamp(g.r - R.y, 1, R.h-1);
      R.splits.h = uniqSorted(R.splits.h, R.h); draw();
    } else if(dragMode==='newSplit'){
      // Decide orientation by movement
      const R = byId(dragData.rectId); if(!R) return;
      const dx = Math.abs(g.c - dragData.start.c), dy = Math.abs(g.r - dragData.start.r);
      if(dx > dy){
        // vertical split at column
        const at = clamp(g.c - R.x, 1, R.w-1);
        dragData.preview = {dir:'v', at};
      } else {
        const at = clamp(g.r - R.y, 1, R.h-1);
        dragData.preview = {dir:'h', at};
      }
      // draw preview line (simple: redraw)
      // add transient to copies then remove? Keep simple: just call draw();
      draw();
      // then overlay preview
      if(dragData.preview){
        const leftX = pad + R.x*dotSpacing, rightX= pad + (R.x + (R.w-1))*dotSpacing;
        const topY  = pad + R.y*dotSpacing, botY  = pad + (R.y + (R.h-1))*dotSpacing;
        const line = document.createElementNS('http://www.w3.org/2000/svg','line');
        if(dragData.preview.dir==='v'){
          const x = pad + (R.x + dragData.preview.at)*dotSpacing;
          line.setAttribute('x1', x); line.setAttribute('x2', x); line.setAttribute('y1', topY); line.setAttribute('y2', botY);
        } else {
          const y = pad + (R.y + dragData.preview.at)*dotSpacing;
          line.setAttribute('x1', leftX); line.setAttribute('x2', rightX); line.setAttribute('y1', y); line.setAttribute('y2', y);
        }
        line.setAttribute('stroke', '#9bd0ff'); line.setAttribute('stroke-dasharray','4 4'); line.setAttribute('stroke-width', getSplitWidth());
        svg.appendChild(line);
      }
    }
  });

  window.addEventListener('pointerup', (e)=>{
    if(e.pointerId) try{ svg.releasePointerCapture(e.pointerId); }catch{}
    if(dragMode==='newSplit' && dragData && dragData.preview){
      const R = sel(); if(R){
        if(dragData.preview.dir==='v'){ R.splits.v = uniqSorted([...R.splits.v, dragData.preview.at], R.w); }
        else { R.splits.h = uniqSorted([...R.splits.h, dragData.preview.at], R.h); }
      }
    }
    dragMode=null; dragData=null; draw();
  });

  // --- Controls wiring ---
  [gridCols, gridRows].forEach(el=> el && el.addEventListener('input', draw));
  if (dotSpacingCtl) dotSpacingCtl.addEventListener('input', draw);
  if (hcToggle) hcToggle.addEventListener('input', ()=>{ if(hcLabel) hcLabel.textContent = hcToggle.checked? 'ON':'OFF'; draw(); });

  function refreshControls(){
    const R = sel();
    rectIdCtl && (rectIdCtl.value = R? R.id : '');
    rWctl && (rWctl.value = R? R.w : 7);
    rHctl && (rHctl.value = R? R.h : 6);
    splitControls && splitControls.classList.toggle('dimmed', !R);
  }

  rWctl && rWctl.addEventListener('input', ()=>{ const R=sel(); if(!R) return; R.w = clamp(+rWctl.value,1,cols-R.x); R.splits.v = uniqSorted(R.splits.v, R.w); draw(); });
  rHctl && rHctl.addEventListener('input', ()=>{ const R=sel(); if(!R) return; R.h = clamp(+rHctl.value,1,rows-R.y); R.splits.h = uniqSorted(R.splits.h, R.h); draw(); });

  btnDelete && btnDelete.addEventListener('click', ()=>{ if(!sel()) return; const idx = rects.findIndex(r=>r.id===selectedId); if(idx>=0){ rects.splice(idx,1); selectedId = rects.length? rects[rects.length-1].id : null; draw(); } });

  btnExample && btnExample.addEventListener('click', ()=>{
    rects.length = 0; nextId=1;
    const R = {id:nextId++, x:2, y:2, w:7, h:6, splits:{v:[6], h:[]}, colors:{border:'#56a0ff'}};
    rects.push(R); selectedId=R.id; gridCols && (gridCols.value=20); gridRows && (gridRows.value=20); dotSpacingCtl && (dotSpacingCtl.value=28); draw();
  });

  btnReset && btnReset.addEventListener('click', ()=>{
    rects.length = 0; nextId=1; selectedId=null;
    gridCols && (gridCols.value=20); gridRows && (gridRows.value=20); dotSpacingCtl && (dotSpacingCtl.value=28);
    if (hcToggle){ hcToggle.checked=false; hcLabel && (hcLabel.textContent='OFF'); }
    draw();
  });

  btnExport && btnExport.addEventListener('click', ()=>{
    const serializer=new XMLSerializer();
    const src=serializer.serializeToString(svg);
    const img=new Image();
    const blob=new Blob([src],{type:'image/svg+xml;charset=utf-8'});
    const url=URL.createObjectURL(blob);
    img.onload=function(){
      const canvas=document.createElement('canvas');
      canvas.width=svg.viewBox.baseVal.width; canvas.height=svg.viewBox.baseVal.height;
      const ctx=canvas.getContext('2d'); ctx.fillStyle='#0a0d11'; ctx.fillRect(0,0,canvas.width,canvas.height);
      ctx.drawImage(img,0,0); URL.revokeObjectURL(url);
      canvas.toBlob((b)=>{ const a=document.createElement('a'); a.download=`partition_multi.png`; a.href=URL.createObjectURL(b); a.click(); });
    }; img.src=url;
  });

  // --- Init with one rect ---
  (function initOne(){
    const R = {id:nextId++, x:1, y:1, w:7, h:6, splits:{v:[], h:[]}, colors:{border:'#56a0ff'}};
    rects.push(R); selectedId=R.id; draw();
  })();
})();
</script>
</body>
</html>
