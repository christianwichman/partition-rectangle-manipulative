<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Multiple 10×10 Arrays – Partitions (single-use tool)</title>
<style>
  :root {
    --cell: 40px;
    --gap: 8px;
    --dot: 14px;
    --red: #ef4444;
    --blue: #2563eb;
  }
  body {
    font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif;
    background: #f7f7f9;
    margin: 0;
    padding: 20px;
    display: grid;
    gap: 16px;
    justify-items: center;
  }
  header {
    display: flex;
    gap: 12px;
    align-items: center;
    flex-wrap: wrap;
  }
  button, .tiny {
    appearance: none; border: 0; border-radius: 8px;
    padding: 10px 14px; background: #10b981; color: #fff;
    font-weight: 600; cursor: pointer;
  }
  button:hover { background: #059669; }
  .tiny { padding: 6px 10px; font-size: 12px; background: #374151; }

  #boards {
    width: min(1000px, 96vw);
    display: grid;
    grid-template-columns: repeat(auto-fill, minmax(420px, 1fr));
    gap: 20px;
  }
  .board {
    background: #fff; border: 1px solid #e5e7eb; border-radius: 12px;
    padding: 14px; box-shadow: 0 1px 3px rgba(0,0,0,.06);
    display: grid; gap: 12px;
  }
  .board-header {
    display: flex; justify-content: space-between; align-items: center;
  }
  .controls { display: flex; gap: 8px; flex-wrap: wrap; }

  .stage {
    position: relative;
    width: calc(10 * var(--cell) + 9 * var(--gap));
    height: calc(10 * var(--cell) + 9 * var(--gap));
    margin-inline: auto;
  }

  .grid {
    position: absolute; inset: 0;
    display: grid;
    grid-template-columns: repeat(10, var(--cell));
    gap: var(--gap);
    justify-content: center;
    align-content: center;
  }

  .overlay {
    position: absolute; inset: 0;
    pointer-events: none; /* enable only while drawing */
  }

  .circle {
    width: var(--cell); height: var(--cell);
    border-radius: 50%;
    border: 1px solid #9ca3af;
    position: relative; /* for blue dot */
    box-sizing: border-box;
    cursor: pointer;
    transition: transform .08s ease;
  }
  .circle:hover { transform: scale(1.05); }

  .red   { background: var(--red); }
  .white { background: #ffffff; }

  /* Blue dot when clicked */
  .clicked::after {
    content: "";
    position: absolute;
    width: var(--dot); height: var(--dot);
    border-radius: 50%;
    background: var(--blue);
    top: 50%; left: 50%;
    transform: translate(-50%, -50%);
    box-shadow: 0 0 0 2px rgba(255,255,255,.7);
  }

  .badge {
    background: #e5e7eb; color: #111827; border-radius: 999px;
    padding: 4px 8px; font-size: 12px; font-weight: 600;
  }
</style>
</head>
<body>
  <header>
    <button id="addBoard">Add 10×10 Array</button>
    <button id="removeBoard" class="tiny">Remove last</button>
  </header>

  <div id="boards"></div>

<script>
(function(){
  const boardsEl = document.getElementById('boards');
  const addBtn   = document.getElementById('addBoard');
  const rmBtn    = document.getElementById('removeBoard');
  let boardCount = 0;

  addBtn.addEventListener('click', () => createBoard());
  rmBtn.addEventListener('click', () => {
    if (boardsEl.lastElementChild) boardsEl.lastElementChild.remove();
  });

  // Create one board to start
  createBoard();

  function createBoard() {
    boardCount++;
    const board = document.createElement('section');
    board.className = 'board';

    board.innerHTML = `
      <div class="board-header">
        <div class="badge">Array ${boardCount}</div>
        <div class="controls">
          <button data-action="rearrange">Rearrange</button>
          <button data-action="draw" class="tiny" title="Draw one partition">Draw Partition</button>
          <button data-action="reset" class="tiny">Reset</button>
        </div>
      </div>
      <div class="stage">
        <div class="grid"></div>
        <svg class="overlay" viewBox="0 0 1000 1000" preserveAspectRatio="none"></svg>
      </div>
    `;

    const grid = board.querySelector('.grid');
    const overlay = board.querySelector('.overlay');
    const drawBtn = board.querySelector('[data-action="draw"]');

    boardsEl.appendChild(board);

    // Build initial pattern and keep references
    const circles = [];
    for (let r = 0; r < 10; r++) {
      for (let c = 0; c < 10; c++) {
        const el = document.createElement('div');
        el.className = 'circle ' + (c < 5 ? 'red' : 'white');
        el.dataset.original = (c < 5 ? 'red' : 'white');
        el.addEventListener('click', () => {
          el.classList.toggle('clicked'); // blue dot on/off
        });
        grid.appendChild(el);
        circles.push(el);
      }
    }

    // Rearrange & Reset buttons (same behavior as before)
    board.querySelector('[data-action="reset"]').addEventListener('click', () => {
      resetBoard(grid, circles);
    });

    board.querySelector('[data-action="rearrange"]').addEventListener('click', () => {
      rearrangeBoard(grid, circles);
    });

    // === One-shot Draw Partition for THIS board ===
    let drawMode = false;      // single-use flag
    let start = null;          // start point in overlay coords
    let previewRect = null;    // SVG rect for live preview
    const savedRects = [];     // keep drawn partitions (optional)

    drawBtn.addEventListener('click', () => {
      drawMode = true;         // enable once
      start = null;
      removePreview();
      overlay.style.pointerEvents = 'auto'; // allow capturing drag
      // (Optional): visual feedback on the button for one-shot
      drawBtn.textContent = 'Draw (active)';
      drawBtn.disabled = true; // prevent re-click until complete
    });

    // Map from client to overlay SVG coordinates (viewBox 0..1000)
    function clientToSvg(evt) {
      const rect = overlay.getBoundingClientRect();
      const x = ((evt.clientX - rect.left) / rect.width) * 1000;
      const y = ((evt.clientY - rect.top)  / rect.height) * 1000;
      return { x, y };
    }

    overlay.addEventListener('mousedown', (e) => {
      if (!drawMode) return;
      start = clientToSvg(e);
      // set up preview rect
      previewRect = document.createElementNS('http://www.w3.org/2000/svg', 'rect');
      previewRect.setAttribute('fill', 'rgba(37,99,235,0.08)');
      previewRect.setAttribute('stroke', '#2563eb');
      previewRect.setAttribute('stroke-width', '3');
      previewRect.setAttribute('stroke-dasharray', '6 6');
      overlay.appendChild(previewRect);
    });

    window.addEventListener('mousemove', (e) => {
      if (!drawMode || !start || !previewRect) return;
      const p = clientToSvg(e);
      const x = Math.min(start.x, p.x);
      const y = Math.min(start.y, p.y);
      const w = Math.abs(p.x - start.x);
      const h = Math.abs(p.y - start.y);
      previewRect.setAttribute('x', x);
      previewRect.setAttribute('y', y);
      previewRect.setAttribute('width', w);
      previewRect.setAttribute('height', h);
    });

    window.addEventListener('mouseup', (e) => {
      if (!drawMode || !start || !previewRect) return;

      // finalize the rectangle
      previewRect.setAttribute('stroke-dasharray', '');
      previewRect.setAttribute('fill', 'rgba(37,99,235,0.12)');
      savedRects.push({
        x: +previewRect.getAttribute('x'),
        y: +previewRect.getAttribute('y'),
        width: +previewRect.getAttribute('width'),
        height: +previewRect.getAttribute('height'),
      });

      // turn OFF one-shot mode immediately
      drawMode = false;
      start = null;
      previewRect = null;
      overlay.style.pointerEvents = 'none';
      drawBtn.textContent = 'Draw Partition';
      drawBtn.disabled = false;
    });

    // Allow cancel with Escape during active draw
    window.addEventListener('keydown', (e) => {
      if (e.key === 'Escape' && drawMode) {
        drawMode = false;
        start = null;
        removePreview();
        overlay.style.pointerEvents = 'none';
        drawBtn.textContent = 'Draw Partition';
        drawBtn.disabled = false;
      }
    });

    function removePreview() {
      if (previewRect && previewRect.parentNode) {
        previewRect.parentNode.removeChild(previewRect);
      }
      previewRect = null;
    }
  }

  // Reset: restore 5 red + 5 white per row and clear clicks; restore DOM order
  function resetBoard(grid, circles) {
    circles.forEach((el, idx) => {
      const col = idx % 10;
      el.className = 'circle ' + (col < 5 ? 'red' : 'white');
      el.dataset.original = (col < 5 ? 'red' : 'white');
    });
    grid.innerHTML = '';
    circles.forEach(el => grid.appendChild(el));
    // Also clear any SVG overlay rects in this board
    const overlay = grid.parentElement.querySelector('.overlay');
    if (overlay) overlay.innerHTML = '';
  }

  // Rearrange: clicked first (keep their red/white + blue dot), then unclicked packed to 5R/5W per row
  function rearrangeBoard(grid, circles) {
    const clicked   = circles.filter(el => el.classList.contains('clicked'));
    const unclicked = circles.filter(el => !el.classList.contains('clicked'));

    // Count remaining unclicked reds/whites
    const pool = {
      red:   unclicked.filter(el => el.classList.contains('red')),
      white: unclicked.filter(el => el.classList.contains('white')),
    };

    // Start with clicked ones first
    const order = [...clicked];

    // Fill remaining cells row-by-row trying for 5 red then 5 white each row
    const total = circles.length;
    const remainingSlots = total - clicked.length;

    for (let i = 0; i < remainingSlots; i++) {
      const col = (order.length % 10);
      const target = col < 5 ? 'red' : 'white';
      let nextEl = null;
      if (pool[target].length) nextEl = pool[target].shift();
      else {
        const other = target === 'red' ? 'white' : 'red';
        if (pool[other].length) nextEl = pool[other].shift();
      }
      if (nextEl) order.push(nextEl);
    }

    // Apply new DOM order
    grid.innerHTML = '';
    order.forEach(el => grid.appendChild(el));
  }

})();
</script>
</body>
</html>
