<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Multiple 10×10 Arrays – Red/White with Click Dots</title>
<style>
  :root {
    --cell: 40px;
    --gap: 8px;
    --dot: 14px;
    --red: #ef4444;
    --blue: #2563eb;
  }
  body {
    font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif;
    background: #f7f7f9;
    margin: 0;
    padding: 20px;
    display: grid;
    gap: 16px;
    justify-items: center;
  }
  header {
    display: flex;
    gap: 12px;
    align-items: center;
    flex-wrap: wrap;
  }
  button, .tiny {
    appearance: none; border: 0; border-radius: 8px;
    padding: 10px 14px; background: #10b981; color: #fff;
    font-weight: 600; cursor: pointer;
  }
  button:hover { background: #059669; }
  .tiny {
    padding: 6px 10px; font-size: 12px; background: #374151;
  }
  #boards {
    width: min(1000px, 96vw);
    display: grid;
    grid-template-columns: repeat(auto-fill, minmax(420px, 1fr));
    gap: 20px;
  }
  .board {
    background: #fff; border: 1px solid #e5e7eb; border-radius: 12px;
    padding: 14px; box-shadow: 0 1px 3px rgba(0,0,0,.06);
    display: grid; gap: 12px;
  }
  .board-header {
    display: flex; justify-content: space-between; align-items: center;
  }
  .controls { display: flex; gap: 8px; flex-wrap: wrap; }
  .grid {
    display: grid;
    grid-template-columns: repeat(10, var(--cell));
    gap: var(--gap);
    justify-content: center;
  }
  .circle {
    width: var(--cell); height: var(--cell);
    border-radius: 50%;
    border: 1px solid #9ca3af;
    position: relative; /* needed for the blue dot */
    box-sizing: border-box;
    cursor: pointer;
    transition: transform .08s ease;
  }
  .circle:hover { transform: scale(1.05); }

  .red   { background: var(--red); }
  .white { background: #ffffff; }

  /* Blue dot appears when clicked */
  .clicked::after {
    content: "";
    position: absolute;
    width: var(--dot); height: var(--dot);
    border-radius: 50%;
    background: var(--blue);
    top: 50%; left: 50%;
    transform: translate(-50%, -50%);
    box-shadow: 0 0 0 2px rgba(255,255,255,.7); /* subtle halo on red */
  }

  .badge {
    background: #e5e7eb; color: #111827; border-radius: 999px;
    padding: 4px 8px; font-size: 12px; font-weight: 600;
  }
</style>
</head>
<body>
  <header>
    <button id="addBoard">Add 10×10 Array</button>
    <button id="removeBoard" class="tiny">Remove last</button>
  </header>

  <div id="boards"></div>

<script>
(function(){
  const boardsEl = document.getElementById('boards');
  const addBtn   = document.getElementById('addBoard');
  const rmBtn    = document.getElementById('removeBoard');
  let boardCount = 0;

  addBtn.addEventListener('click', () => createBoard());
  rmBtn.addEventListener('click', () => {
    if (boardsEl.lastElementChild) boardsEl.lastElementChild.remove();
  });

  // Create one board by default
  createBoard();

  function createBoard() {
    boardCount++;
    const board = document.createElement('section');
    board.className = 'board';

    board.innerHTML = `
      <div class="board-header">
        <div class="badge">Array ${boardCount}</div>
        <div class="controls">
          <button data-action="rearrange">Rearrange</button>
          <button data-action="reset" class="tiny">Reset</button>
        </div>
      </div>
      <div class="grid"></div>
    `;

    const grid = board.querySelector('.grid');
    boardsEl.appendChild(board);

    // Build initial pattern
    const circles = [];
    for (let r = 0; r < 10; r++) {
      for (let c = 0; c < 10; c++) {
        const el = document.createElement('div');
        el.className = 'circle ' + (c < 5 ? 'red' : 'white');
        el.dataset.original = (c < 5 ? 'red' : 'white');
        el.addEventListener('click', () => {
          el.classList.toggle('clicked'); // blue dot on/off
        });
        grid.appendChild(el);
        circles.push(el);
      }
    }

    // Button handlers
    board.querySelector('[data-action="reset"]').addEventListener('click', () => {
      resetBoard(grid, circles);
    });

    board.querySelector('[data-action="rearrange"]').addEventListener('click', () => {
      rearrangeBoard(grid, circles);
    });
  }

  // Reset to 5 red + 5 white per row and clear clicks
  function resetBoard(grid, circles) {
    circles.forEach((el, idx) => {
      const col = idx % 10;
      el.classList.remove('clicked', 'red', 'white');
      const base = (col < 5 ? 'red' : 'white');
      el.classList.add(base);
      el.dataset.original = base;
    });
    // Restore DOM order to original grid order
    grid.innerHTML = '';
    circles.forEach(el => grid.appendChild(el));
  }

  // Rearrange: clicked first (keep original colours), then unclicked packed to 5R/5W per row
  function rearrangeBoard(grid, circles) {
    const clicked   = circles.filter(el => el.classList.contains('clicked'));
    const unclicked = circles.filter(el => !el.classList.contains('clicked'));

    // Count remaining unclicked reds/whites
    const pool = {
      red:   unclicked.filter(el => el.classList.contains('red')),
      white: unclicked.filter(el => el.classList.contains('white')),
    };

    // Build the target order:
    // 1) all clicked in their current order (original colours preserved)
    const order = [...clicked];

    // 2) fill remaining slots row-by-row trying for 5 red then 5 white each row
    const total = circles.length;
    const remainingSlots = total - clicked.length;

    for (let i = 0; i < remainingSlots; i++) {
      const col = ( (order.length) % 10 ); // current column index 0..9
      const targetColor = col < 5 ? 'red' : 'white';
      // Choose from target pool if available; otherwise fallback to the other
      let nextEl = null;
      if (pool[targetColor].length) {
        nextEl = pool[targetColor].shift();
      } else {
        const other = targetColor === 'red' ? 'white' : 'red';
        if (pool[other].length) {
          nextEl = pool[other].shift();
        }
      }
      if (nextEl) order.push(nextEl);
      else break; // shouldn't happen, but safety
    }

    // Re-append in new order
    grid.innerHTML = '';
    order.forEach(el => grid.appendChild(el));
  }

})();
</script>
</body>
</html>
