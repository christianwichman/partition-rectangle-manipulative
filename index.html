<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Rectangle Partitions — SVG UI (aligned fills)</title>
<style>
  :root { --bg:#0b0d10; --ui:#11151a; --ink:#e8eef6; --muted:#aeb6c2; --accent:#56a0ff; --accent2:#ffa756; }
  *{box-sizing:border-box}
  body{margin:0;background:var(--bg);color:var(--ink);font-family:system-ui,-apple-system,Inter,Roboto,Arial,sans-serif}
  header{padding:14px 18px;background:var(--ui);position:sticky;top:0;z-index:2;border-bottom:1px solid #1c222a}
  header h1{margin:0;font-size:16px;font-weight:600}
  .wrap{display:grid;grid-template-columns:300px 1fr;gap:14px;padding:14px}
  @media (max-width: 900px){ .wrap{grid-template-columns:1fr} }
  .panel{background:var(--ui);border:1px solid #1c222a;border-radius:12px;padding:12px}
  .panel h2{margin:0 0 8px 0;font-size:14px;color:var(--muted);font-weight:600}
  .row{display:grid;grid-template-columns:1fr 130px;gap:8px;align-items:center;margin:8px 0}
  label{font-size:13px}
  input[type="number"], select{
    width:100%;background:#0f1318;color:var(--ink);
    border:1px solid #1c222a;border-radius:8px;padding:8px 10px;font-size:14px;
  }
  .btns{display:flex;gap:8px;flex-wrap:wrap;margin-top:8px}
  button{
    background:#19202a;color:var(--ink);border:1px solid #263043;border-radius:10px;
    padding:9px 12px;font-size:14px;cursor:pointer
  }
  button:hover{border-color:#36507a}
  #equation{font-variant-numeric:tabular-nums;line-height:1.35;background:#0f1318;border:1px solid #1c222a;border-radius:10px;padding:10px;margin-top:8px}
  .note{color:var(--muted);font-size:12px;margin-top:8px}
  .canvasWrap{position:relative;overflow:auto;background:#0a0d11;border:1px solid #1c222a;border-radius:12px;height:72vh;min-height:420px}
  svg{display:block}
  .legend{display:flex;gap:10px;align-items:center;font-size:12px;color:var(--muted);margin-top:6px}
  .swatch{width:14px;height:14px;border-radius:3px;display:inline-block;border:1px solid #0004}
  .toggle{
    display:inline-flex;align-items:center;gap:8px;background:#19202a;border:1px solid #263043;border-radius:999px;
    padding:6px 10px;cursor:pointer;user-select:none
  }
  .toggle input{appearance:none;width:22px;height:22px;border-radius:999px;border:1px solid #36507a;background:#0f1318;display:inline-block;position:relative}
  .toggle input:checked{background:#2c82ff}
  .dimmed{opacity:0.55;pointer-events:none}
  .panelHead{display:flex;align-items:center;justify-content:space-between;gap:8px;margin-bottom:8px}
  .panelHead h2{margin:0;font-size:14px;color:var(--muted);font-weight:600}
  .collapser{background:#19202a;color:var(--ink);border:1px solid #263043;border-radius:8px;padding:6px 10px;font-size:12px;cursor:pointer}
  .collapser:hover{border-color:#36507a}
  .panel.collapsed #controlsBody{display:none}
</style>
</head>
<body>
<header><h1>Rectangle Partitions — Toggle & Drag</h1></header>

<div class="wrap">
  <div class="panel">
    <div class="panelHead"><h2>Controls</h2><button id="collapseControls" class="collapser" aria-expanded="true" aria-controls="controlsBody" title="Collapse/expand controls">Hide</button></div>
    <div id="controlsBody">
      <div class="row">
      <label>Dots across (columns)</label><input id="gridCols" type="number" min="5" max="60" value="20">
    </div>
    <div class="row">
      <label>Dots down (rows)</label><input id="gridRows" type="number" min="5" max="60" value="20">
    </div>

    

    
      <div class="row">
        <label>Split at</label>
        <input id="splitAt" type="number" min="0" value="6">
      </div>
    </div>

    <div class="row" style="grid-template-columns:1fr auto"><label>High-contrast / thick lines</label><label class="toggle"><span id="hcLabel">OFF</span><input id="hcToggle" type="checkbox"></label></div>
    <div class="row"><label>Theme</label>
      <select id="themeSel">
        <option value="dark" selected>Dark</option>
        <option value="contrast">High Contrast Dark</option>
        <option value="light">Light</option>
      </select>
    </div>

    <div class="note"><b>Partitions:</b> Shift+drag inside a selected rectangle to add a partition (drag direction decides vertical or horizontal). Drag a partition line to move it. Ctrl/Cmd+click a partition line to delete it.</div>

    <div class="btns">
      <button id="reset">Reset</button>
      <button id="delete" class="danger">Delete selected</button>
      <button id="export">Export PNG</button>
    </div>

    <div id="equation" aria-live="polite"></div>
    <div class="legend">
      <span class="swatch" style="background:#ffffff; border:1px solid #1c222a"></span> Dots
      <span class="kbd">Drag empty grid: new rect</span>
      <span class="kbd">Click rect: select</span>
      <span class="kbd">Drag selected: move</span>
      <span class="kbd">Shift+drag inside: add partition (auto H/V)</span>
      <span class="kbd">Drag line: move partition</span>
      <span class="kbd">Ctrl+click line: delete partition</span>
    </div>
    <div class="note">
      Tip: <b>Drag from one dot to another</b> to draw a rectangle. <b>Drag inside</b> to move it. Use <b>Shift+drag</b> to add partitions; <b>drag a line</b> to adjust; <b>Ctrl/Cmd+click</b> to delete.
    </div>
  </div>
  </div>

  <div class="panel canvasWrap">
    <svg id="board" xmlns="http://www.w3.org/2000/svg" role="img" aria-label="Dot grid with draggable rectangle and optional partition"></svg>
  </div>
</div>

<script>
(function(){
  // --- State ---
  let dotSpacing = 28, pad = 30;
  let cols = 20, rows = 20;
  let nextId = 1;
  const rects = []; // {id,x,y,w,h, splits:{v:[],h:[]}}
  let selectedId = null;
  let dragMode = null, dragData = null; // 'new','move','splitV','splitH','newSplit'
  let theme = 'dark';

  // --- DOM ---
  const svg = document.getElementById('board');
  const gridCols = document.getElementById('gridCols');
  const gridRows = document.getElementById('gridRows');
  const dotSpacingCtl = document.getElementById('dotSpacingCtl');
  const hcToggle = document.getElementById('hcToggle');
  const hcLabel = document.getElementById('hcLabel');
  const themeSel = document.getElementById('themeSel');

  const equation  = document.getElementById('equation');
  const btnReset  = document.getElementById('reset');
  const btnDelete = document.getElementById('delete');
  const btnExport = document.getElementById('export');

  const controlsPanel = document.querySelector('.wrap > .panel');
  const collapseBtn = document.getElementById('collapseControls');

  // --- Helpers ---
  const clamp = (v,min,max)=>Math.max(min,Math.min(max,v));
  const byId = id => rects.find(r=>r.id===id) || null;
  const sel = ()=> byId(selectedId);
  const snapGrid = (x,y)=>({ c: clamp(Math.round((x - pad)/dotSpacing), 0, cols-1),
                              r: clamp(Math.round((y - pad)/dotSpacing), 0, rows-1) });
  const sizeSVG = ()=>{ const w = pad*2 + (cols-1)*dotSpacing, h = pad*2 + (rows-1)*dotSpacing; svg.setAttribute('viewBox',`0 0 ${w} ${h}`); svg.setAttribute('width',w); svg.setAttribute('height',h); };
  const insideRect = (R,c,rr)=> c>=R.x && c<=R.x+(R.w-1) && rr>=R.y && rr<=R.y+(R.h-1);

  function getStrokeWidth(){ return hcToggle && hcToggle.checked? 3.2 : 2.4; }
  function getSplitWidth(){  return hcToggle && hcToggle.checked? 3.0 : 2.2; }
  function getDotRadius(){   return hcToggle && hcToggle.checked? 3.6 : 2.8; }
  function getDotColor(){ return theme==='light' ? '#1a1f26' : '#ffffff'; }
  function getSplitColor(){ return theme==='contrast' ? '#ffed75' : '#ffd7a8'; }
  function getBorderColor(){ return theme==='contrast' ? '#7ad7ff' : '#56a0ff'; }

  function uniqSorted(arr, max){
    const set = new Set(arr.filter(n=>Number.isInteger(n) && n>0 && n<max));
    return Array.from(set).sort((a,b)=>a-b);
  }

  // --- Drawing ---
  function draw(){
    cols = clamp(+gridCols.value,5,60);
    rows = clamp(+gridRows.value,5,60);
    if (dotSpacingCtl) dotSpacing = clamp(+dotSpacingCtl.value || 28,16,60);

    sizeSVG(); while(svg.firstChild) svg.removeChild(svg.firstChild);

    // Dots
    const dotGroup = document.createElementNS('http://www.w3.org/2000/svg','g');
    for(let rr=0; rr<rows; rr++){
      for(let cc=0; cc<cols; cc++){
        const cx = pad + cc*dotSpacing, cy = pad + rr*dotSpacing;
        const dot = document.createElementNS('http://www.w3.org/2000/svg','circle');
        dot.setAttribute('cx', cx); dot.setAttribute('cy', cy);
        dot.setAttribute('r', getDotRadius()); dot.setAttribute('fill', getDotColor());
        dotGroup.appendChild(dot);
      }
    }
    svg.appendChild(dotGroup);

    // Rects + partitions
    rects.forEach(R=>{
      const leftX = pad + R.x*dotSpacing;
      const rightX= pad + (R.x + (R.w-1))*dotSpacing;
      const topY  = pad + R.y*dotSpacing;
      const botY  = pad + (R.y + (R.h-1))*dotSpacing;

      // partition lines
      (R.splits.v||[]).forEach(at=>{
        const x = pad + (R.x + at)*dotSpacing;
        const line = document.createElementNS('http://www.w3.org/2000/svg','line');
        line.setAttribute('x1', x); line.setAttribute('x2', x);
        line.setAttribute('y1', topY); line.setAttribute('y2', botY);
        line.setAttribute('stroke', getSplitColor());
        line.setAttribute('stroke-width', getSplitWidth());
        line.dataset.rect = R.id; line.dataset.dir='v'; line.dataset.at=at;
        svg.appendChild(line);
      });
      (R.splits.h||[]).forEach(at=>{
        const y = pad + (R.y + at)*dotSpacing;
        const line = document.createElementNS('http://www.w3.org/2000/svg','line');
        line.setAttribute('x1', leftX); line.setAttribute('x2', rightX);
        line.setAttribute('y1', y); line.setAttribute('y2', y);
        line.setAttribute('stroke', getSplitColor());
        line.setAttribute('stroke-width', getSplitWidth());
        line.dataset.rect = R.id; line.dataset.dir='h'; line.dataset.at=at;
        svg.appendChild(line);
      });

      // border
      const br = document.createElementNS('http://www.w3.org/2000/svg','rect');
      br.setAttribute('x', leftX); br.setAttribute('y', topY);
      br.setAttribute('width', (R.w-1)*dotSpacing);
      br.setAttribute('height',(R.h-1)*dotSpacing);
      br.setAttribute('fill','none');
      br.setAttribute('stroke', getBorderColor());
      br.setAttribute('stroke-width', selectedId===R.id? getStrokeWidth()*1.35 : getStrokeWidth());
      svg.appendChild(br);

      addLabels(R);
    });

    updateEquation();
  }

  function segmentLabelsPositions(len, splits){
    const pts = [0, ...splits, len];
    const out = [];
    for(let i=0;i<pts.length-1;i++){
      const a = pts[i], b = pts[i+1];
      out.push({a, b, length: b-a, mid: (a+b)/2});
    }
    return out;
  }

  function addLabels(R){
    const g = document.createElementNS('http://www.w3.org/2000/svg','g');
    g.setAttribute('font-size','12'); g.setAttribute('fill','#e8eef6');

    const leftX = pad + R.x*dotSpacing;
    const topY  = pad + R.y*dotSpacing;

    const vSplits = uniqSorted(R.splits.v||[], R.w);
    const hSplits = uniqSorted(R.splits.h||[], R.h);

    const wSegs = segmentLabelsPositions(R.w, vSplits);
    const hSegs = segmentLabelsPositions(R.h, hSplits);

    const topYLabel = Math.max(12, topY - 10);
    wSegs.forEach(seg=>{
      const x = pad + (R.x + seg.mid)*dotSpacing;
      const t = document.createElementNS('http://www.w3.org/2000/svg','text');
      t.setAttribute('x', x); t.setAttribute('y', topYLabel);
      t.setAttribute('text-anchor','middle'); t.textContent = `${seg.length}`; g.appendChild(t);
    });

    const leftXLabel = Math.max(10, leftX - 10);
    hSegs.forEach(seg=>{
      const y = pad + (R.y + seg.mid)*dotSpacing + 4;
      const t = document.createElementNS('http://www.w3.org/2000/svg','text');
      t.setAttribute('x', leftXLabel); t.setAttribute('y', y);
      t.setAttribute('text-anchor','middle'); t.textContent = `${seg.length}`; g.appendChild(t);
    });

    svg.appendChild(g);
  }

  // --- Equation / single-line decomposition ---
  function updateEquation(){
    const R = sel();
    if(!R){ equation.innerHTML = '<i>No rectangle selected. Drag on the grid to create one, or click a rectangle to select.</i>'; return; }
    const total = R.w * R.h;
    const v = uniqSorted(R.splits.v||[], R.w), h = uniqSorted(R.splits.h||[], R.h);

    const wSegs = segmentLabelsPositions(R.w, v).map(s=>s.length);
    const hSegs = segmentLabelsPositions(R.h, h).map(s=>s.length);

    let line = `${R.h} × ${R.w}`;
    if (wSegs.length>1 || hSegs.length>1){
      if (wSegs.length >= hSegs.length){
        const rhs = wSegs.map(w=>`${R.h} × ${w}`).join(' + ');
        line += ` = ${rhs}`;
      } else {
        const rhs = hSegs.map(hh=>`${hh} × ${R.w}`).join(' + ');
        line += ` = ${rhs}`;
      }
    }
    equation.innerHTML = `<div>${line} = <b>${total}</b></div>`;
  }

  // --- Interaction ---
  function svgPointFromEvent(e){ const pt = svg.createSVGPoint(); pt.x = e.clientX; pt.y = e.clientY; return pt.matrixTransform(svg.getScreenCTM().inverse()); }
  function rectAt(c,r){ return rects.slice().reverse().find(R=>insideRect(R,c,r)) || null; }

  function nearestSplit(R, p){
    const tol = 8;
    const leftX = pad + R.x*dotSpacing;
    const rightX= pad + (R.x + (R.w-1))*dotSpacing;
    const topY  = pad + R.y*dotSpacing;
    const botY  = pad + (R.y + (R.h-1))*dotSpacing;
    for(let i=0;i<(R.splits.v||[]).length;i++){
      const at = R.splits.v[i]; const x = pad + (R.x + at)*dotSpacing;
      if (Math.abs(p.x - x) <= tol && p.y >= topY && p.y <= botY) return {dir:'v', index:i};
    }
    for(let i=0;i<(R.splits.h||[]).length;i++){
      const at = R.splits.h[i]; const y = pad + (R.y + at)*dotSpacing;
      if (Math.abs(p.y - y) <= tol && p.x >= leftX && p.x <= rightX) return {dir:'h', index:i};
    }
    return null;
  }

  svg.addEventListener('pointerdown', (e)=>{
    const p = svgPointFromEvent(e), g = snapGrid(p.x, p.y);
    const R = rectAt(g.c, g.r);
    if(R){
      selectedId = R.id;

      const near = nearestSplit(R, p);
      if (near && (e.ctrlKey || e.metaKey)){
        if (near.dir==='v') R.splits.v.splice(near.index,1); else R.splits.h.splice(near.index,1);
        draw(); return;
      }
      if (near){
        dragMode = (near.dir==='v') ? 'splitV' : 'splitH';
        dragData = { rectId:R.id, index:near.index };
        svg.setPointerCapture(e.pointerId); return;
      }
      if(e.shiftKey){ dragMode='newSplit'; dragData={ rectId:R.id, start:g }; svg.setPointerCapture(e.pointerId); return; }
      dragMode='move'; dragData={ rectId:R.id, startC:g.c, startR:g.r, startX:R.x, startY:R.y }; svg.setPointerCapture(e.pointerId);
    } else { dragMode='new'; dragData={ startC:g.c, startR:g.r }; svg.setPointerCapture(e.pointerId); }
  });

  svg.addEventListener('pointermove', (e)=>{
    if(!dragMode) return;
    const p = svgPointFromEvent(e), g = snapGrid(p.x, p.y);
    if(dragMode==='new'){
      const minC=Math.min(dragData.startC,g.c), maxC=Math.max(dragData.startC,g.c);
      const minR=Math.min(dragData.startR,g.r), maxR=Math.max(dragData.startR,g.r);
      if(!dragData.tempId){ const id = nextId++; const R = {id, x:minC, y:minR, w:(maxC-minC)+1, h:(maxR-minR)+1, splits:{v:[],h:[]}}; rects.push(R); selectedId=id; dragData.tempId=id; }
      else { const R = byId(dragData.tempId); R.x=minC; R.y=minR; R.w=(maxC-minC)+1; R.h=(maxR-minR)+1; }
      draw();
    } else if(dragMode==='move'){
      const R = byId(dragData.rectId); if(!R) return;
      const dC=g.c-dragData.startC, dR=g.r-dragData.startR;
      R.x = clamp(dragData.startX + dC, 0, cols - R.w);
      R.y = clamp(dragData.startY + dR, 0, rows - R.h);
      draw();
    } else if(dragMode==='splitV'){
      const R = byId(dragData.rectId); if(!R) return;
      R.splits.v[dragData.index] = clamp(g.c - R.x, 1, R.w-1);
      R.splits.v = uniqSorted(R.splits.v, R.w); draw();
    } else if(dragMode==='splitH'){
      const R = byId(dragData.rectId); if(!R) return;
      R.splits.h[dragData.index] = clamp(g.r - R.y, 1, R.h-1);
      R.splits.h = uniqSorted(R.splits.h, R.h); draw();
    } else if(dragMode==='newSplit'){
      const R = byId(dragData.rectId); if(!R) return;
      const dx = Math.abs(g.c - dragData.start.c), dy = Math.abs(g.r - dragData.start.r);
      dragData.preview = (dx > dy) ? {dir:'v', at: clamp(g.c - R.x, 1, R.w-1)} : {dir:'h', at: clamp(g.r - R.y, 1, R.h-1)};
      draw();
      const leftX = pad + R.x*dotSpacing, rightX= pad + (R.x + (R.w-1))*dotSpacing;
      const topY  = pad + R.y*dotSpacing, botY  = pad + (R.y + (R.h-1))*dotSpacing;
      const line = document.createElementNS('http://www.w3.org/2000/svg','line');
      if(dragData.preview.dir==='v'){ const x = pad + (R.x + dragData.preview.at)*dotSpacing; line.setAttribute('x1', x); line.setAttribute('x2', x); line.setAttribute('y1', topY); line.setAttribute('y2', botY); }
      else { const y = pad + (R.y + dragData.preview.at)*dotSpacing; line.setAttribute('x1', leftX); line.setAttribute('x2', rightX); line.setAttribute('y1', y); line.setAttribute('y2', y); }
      line.setAttribute('stroke', theme==='contrast' ? '#7ad7ff' : '#9bd0ff'); line.setAttribute('stroke-dasharray','4 4'); line.setAttribute('stroke-width', getSplitWidth()); svg.appendChild(line);
    }
  });

  window.addEventListener('pointerup', (e)=>{
    if(e.pointerId) try{ svg.releasePointerCapture(e.pointerId); }catch{}
    if(dragMode==='newSplit' && dragData && dragData.preview){ const R = sel(); if(R){ if(dragData.preview.dir==='v'){ R.splits.v = uniqSorted([...R.splits.v, dragData.preview.at], R.w); } else { R.splits.h = uniqSorted([...R.splits.h, dragData.preview.at], R.h); } } }
    dragMode=null; dragData=null; draw();
  });

  // --- Controls wiring ---
  [gridCols, gridRows].forEach(el=> el && el.addEventListener('input', draw));
  if (dotSpacingCtl) dotSpacingCtl.addEventListener('input', draw);
  if (hcToggle) hcToggle.addEventListener('input', ()=>{ if(hcLabel) hcLabel.textContent = hcToggle.checked? 'ON':'OFF'; draw(); });
  if (themeSel) themeSel.addEventListener('input', ()=>{ theme = themeSel.value; draw(); });

  btnDelete && btnDelete.addEventListener('click', ()=>{ if(!sel()) return; const idx = rects.findIndex(r=>r.id===selectedId); if(idx>=0){ rects.splice(idx,1); selectedId = rects.length? rects[rects.length-1].id : null; draw(); } });

  btnReset && btnReset.addEventListener('click', ()=>{
    rects.length = 0; nextId=1; selectedId=null;
    gridCols && (gridCols.value=20); gridRows && (gridRows.value=20); dotSpacingCtl && (dotSpacingCtl.value=28);
    if (hcToggle){ hcToggle.checked=false; hcLabel && (hcLabel.textContent='OFF'); }
    themeSel && (themeSel.value='dark'); theme='dark';
    draw();
  });

  btnExport && btnExport.addEventListener('click', ()=>{
    const serializer=new XMLSerializer();
    const src=serializer.serializeToString(svg);
    const img=new Image();
    const blob=new Blob([src],{type:'image/svg+xml;charset=utf-8'});
    const url=URL.createObjectURL(blob);
    img.onload=function(){ const canvas=document.createElement('canvas'); canvas.width=svg.viewBox.baseVal.width; canvas.height=svg.viewBox.baseVal.height; const ctx=canvas.getContext('2d'); ctx.fillStyle= (theme==='light'? '#f3f6fb' : '#0a0d11'); ctx.fillRect(0,0,canvas.width,canvas.height); ctx.drawImage(img,0,0); URL.revokeObjectURL(url); canvas.toBlob((b)=>{ const a=document.createElement('a'); a.download=`partition_multi.png`; a.href=URL.createObjectURL(b); a.click(); }); };
    img.src=url;
  });

  // Collapsible controls
  if (collapseBtn){
    collapseBtn.addEventListener('click', ()=>{
      controlsPanel.classList.toggle('collapsed');
      const open = !controlsPanel.classList.contains('collapsed');
      collapseBtn.setAttribute('aria-expanded', open);
      collapseBtn.textContent = open ? 'Hide' : 'Show';
    });
  }

  // --- Init with one rect ---
  (function initOne(){ const R = {id:nextId++, x:1, y:1, w:7, h:6, splits:{v:[], h:[]}}; rects.push(R); selectedId=R.id; draw(); })();
})();
</script>
</body>
</html>
