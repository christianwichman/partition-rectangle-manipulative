<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Rectangle Partitions — SVG UI (aligned fills)</title>
<style>
  :root { --bg:#0b0d10; --ui:#11151a; --ink:#e8eef6; --muted:#aeb6c2; --accent:#56a0ff; --accent2:#ffa756; }
  *{box-sizing:border-box}
  body{margin:0;background:var(--bg);color:var(--ink);font-family:system-ui,-apple-system,Inter,Roboto,Arial,sans-serif}
  header{padding:14px 18px;background:var(--ui);position:sticky;top:0;z-index:2;border-bottom:1px solid #1c222a}
  header h1{margin:0;font-size:16px;font-weight:600}
  .wrap{display:grid;grid-template-columns:300px 1fr;gap:14px;padding:14px}
  @media (max-width: 900px){ .wrap{grid-template-columns:1fr} }
  .panel{background:var(--ui);border:1px solid #1c222a;border-radius:12px;padding:12px}
  .panel h2{margin:0 0 8px 0;font-size:14px;color:var(--muted);font-weight:600}
  .row{display:grid;grid-template-columns:1fr 130px;gap:8px;align-items:center;margin:8px 0}
  label{font-size:13px}
  input[type="number"], select{
    width:100%;background:#0f1318;color:var(--ink);
    border:1px solid #1c222a;border-radius:8px;padding:8px 10px;font-size:14px;
  }
  .btns{display:flex;gap:8px;flex-wrap:wrap;margin-top:8px}
  button{
    background:#19202a;color:var(--ink);border:1px solid #263043;border-radius:10px;
    padding:9px 12px;font-size:14px;cursor:pointer
  }
  button:hover{border-color:#36507a}
  #equation{font-variant-numeric:tabular-nums;line-height:1.35;background:#0f1318;border:1px solid #1c222a;border-radius:10px;padding:10px;margin-top:8px}
  .note{color:var(--muted);font-size:12px;margin-top:8px}
  .canvasWrap{position:relative;overflow:auto;background:#0a0d11;border:1px solid #1c222a;border-radius:12px;height:72vh;min-height:420px}
  svg{display:block}
  .legend{display:flex;gap:10px;align-items:center;font-size:12px;color:var(--muted);margin-top:6px}
  .swatch{width:14px;height:14px;border-radius:3px;display:inline-block;border:1px solid #0004}
  .toggle{
    display:inline-flex;align-items:center;gap:8px;background:#19202a;border:1px solid #263043;border-radius:999px;
    padding:6px 10px;cursor:pointer;user-select:none
  }
  .toggle input{appearance:none;width:22px;height:22px;border-radius:999px;border:1px solid #36507a;background:#0f1318;display:inline-block;position:relative}
  .toggle input:checked{background:#2c82ff}
  .dimmed{opacity:0.55;pointer-events:none}
</style>
</head>
<body>
<header><h1>Rectangle Partitions — Toggle & Drag</h1></header>

<div class="wrap">
  <div class="panel">
    <h2>Controls</h2>

    <div class="row">
      <label>Dots across (columns)</label><input id="gridCols" type="number" min="5" max="60" value="20">
    </div>
    <div class="row">
      <label>Dots down (rows)</label><input id="gridRows" type="number" min="5" max="60" value="20">
    </div>

    <div class="row" style="grid-template-columns:1fr auto">
      <label>Partition</label>
      <label class="toggle">
        <span id="partLabel">OFF</span>
        <input id="partToggle" type="checkbox" />
      </label>
    </div>

    <div id="splitControls">
      <div class="row">
        <label>Split direction</label>
        <select id="splitDir">
          <option value="vertical">Vertical (split columns)</option>
          <option value="horizontal">Horizontal (split rows)</option>
        </select>
      </div>
      <div class="row">
        <label>Split at</label>
        <input id="splitAt" type="number" min="0" value="6">
      </div>
    </div>

    <div class="btns">
      <button id="example">Example 6×7 → 6+1</button>
      <button id="reset">Reset</button>
      <button id="export">Export PNG</button>
    </div>

    <div id="equation" aria-live="polite"></div>
    <div class="legend">
      <span class="swatch" style="background:#56a0ff66"></span> Part A
      <span class="swatch" style="background:#ffa75666"></span> Part B
      <span class="swatch" style="background:#ffffff; border:1px solid #1c222a"></span> Dots
    </div>
    <div class="note">
      Tip: <b>Drag from one dot to another</b> to draw a rectangle. <b>Drag inside</b> to move it. When partition is ON, <b>drag the split line</b> to adjust it.
    </div>
  </div>

  <div class="panel canvasWrap">
    <svg id="board" xmlns="http://www.w3.org/2000/svg" role="img" aria-label="Dot grid with draggable rectangle and optional partition"></svg>
  </div>
</div>

<script>
(function(){
  const dotSpacing = 28, dotRadius = 2.8, pad = 30;

  const svg = document.getElementById('board');
  const gridCols = document.getElementById('gridCols');
  const gridRows = document.getElementById('gridRows');
  const splitDir  = document.getElementById('splitDir');
  const splitAt   = document.getElementById('splitAt');
  const equation  = document.getElementById('equation');
  const btnExample= document.getElementById('example');
  const btnReset  = document.getElementById('reset');
  const btnExport = document.getElementById('export');
  const partToggle= document.getElementById('partToggle');
  const partLabel = document.getElementById('partLabel');
  const splitControls = document.getElementById('splitControls');

  let cols = +gridCols.value, rows = +gridRows.value;
  let rX = 1, rY = 1, rW = 7, rH = 6; // 6×7
  let partDir = 'vertical', sAt = +splitAt.value;
  let partitionEnabled = false;

  let dragMode = null, dragData = null;

  const clamp = (v,min,max)=>Math.max(min,Math.min(max,v));
  const snapGrid = (x,y)=>({ c: clamp(Math.round((x - pad)/dotSpacing), 0, cols-1),
                              r: clamp(Math.round((y - pad)/dotSpacing), 0, rows-1) });

  const sizeSVG = ()=>{
    const w = pad*2 + (cols-1)*dotSpacing;
    const h = pad*2 + (rows-1)*dotSpacing;
    svg.setAttribute('viewBox', `0 0 ${w} ${h}`);
    svg.setAttribute('width', w);
    svg.setAttribute('height', h);
  };

  const insideRect = (c,r)=> c>=rX && c<=rX+(rW-1) && r>=rY && r<=rY+(rH-1);

  function nearSplit(x,y){
    if (!partitionEnabled) return false;
    if (partDir==='vertical'){
      const spx = pad + (rX + sAt)*dotSpacing;
      return Math.abs(x - spx) <= 8 && y >= pad + rY*dotSpacing && y <= pad + (rY + (rH-1))*dotSpacing;
    } else {
      const spy = pad + (rY + sAt)*dotSpacing;
      return Math.abs(y - spy) <= 8 && x >= pad + rX*dotSpacing && x <= pad + (rX + (rW-1))*dotSpacing;
    }
  }

  function draw(){
    cols = clamp(+gridCols.value,5,60);
    rows = clamp(+gridRows.value,5,60);
    partDir = splitDir.value;
    sAt = clamp(+splitAt.value, 0, partDir==='vertical' ? rW : rH);

    rW = clamp(rW,1,cols); rH = clamp(rH,1,rows);
    rX = clamp(rX,0,cols - rW); rY = clamp(rY,0,rows - rH);

    sizeSVG();
    while (svg.firstChild) svg.removeChild(svg.firstChild);

    // Dots
    const dotGroup = document.createElementNS('http://www.w3.org/2000/svg','g');
    for(let rr=0; rr<rows; rr++){
      for(let cc=0; cc<cols; cc++){
        const cx = pad + cc*dotSpacing, cy = pad + rr*dotSpacing;
        const dot = document.createElementNS('http://www.w3.org/2000/svg','circle');
        dot.setAttribute('cx', cx); dot.setAttribute('cy', cy);
        dot.setAttribute('r', dotRadius); dot.setAttribute('fill', '#ffffff');
        dotGroup.appendChild(dot);
      }
    }
    svg.appendChild(dotGroup);

    // === Partition fills/line (aligned using absolute coordinates) ===
    if (partitionEnabled){
      const area = document.createElementNS('http://www.w3.org/2000/svg','g');

      // Rectangle edges in px (from dot to dot)
      const leftX   = pad + rX*dotSpacing;
      const rightX  = pad + (rX + (rW-1))*dotSpacing;
      const topY    = pad + rY*dotSpacing;
      const bottomY = pad + (rY + (rH-1))*dotSpacing;

      if (partDir==='vertical'){
        const splitX = pad + (rX + sAt)*dotSpacing;

        // Left fill: [leftX, splitX)
        if (splitX > leftX){
          const rectA = document.createElementNS('http://www.w3.org/2000/svg','rect');
          rectA.setAttribute('x', leftX);
          rectA.setAttribute('y', topY);
          rectA.setAttribute('width', splitX - leftX);
          rectA.setAttribute('height', bottomY - topY);
          rectA.setAttribute('fill','#56a0ff'); rectA.setAttribute('fill-opacity','0.40');
          area.appendChild(rectA);
        }

        // Right fill: [splitX, rightX]
        if (rightX > splitX){
          const rectB = document.createElementNS('http://www.w3.org/2000/svg','rect');
          rectB.setAttribute('x', splitX);
          rectB.setAttribute('y', topY);
          rectB.setAttribute('width', rightX - splitX);
          rectB.setAttribute('height', bottomY - topY);
          rectB.setAttribute('fill','#ffa756'); rectB.setAttribute('fill-opacity','0.40');
          area.appendChild(rectB);
        }

        const line = document.createElementNS('http://www.w3.org/2000/svg','line');
        line.setAttribute('x1', splitX); line.setAttribute('x2', splitX);
        line.setAttribute('y1', topY);  line.setAttribute('y2', bottomY);
        line.setAttribute('stroke','#ffd7a8'); line.setAttribute('stroke-width','2.2');
        area.appendChild(line);
      } else {
        const splitY = pad + (rY + sAt)*dotSpacing;

        // Top fill: [topY, splitY)
        if (splitY > topY){
          const rectA = document.createElementNS('http://www.w3.org/2000/svg','rect');
          rectA.setAttribute('x', leftX);
          rectA.setAttribute('y', topY);
          rectA.setAttribute('width', rightX - leftX);
          rectA.setAttribute('height', splitY - topY);
          rectA.setAttribute('fill','#56a0ff'); rectA.setAttribute('fill-opacity','0.40');
          area.appendChild(rectA);
        }

        // Bottom fill: [splitY, bottomY]
        if (bottomY > splitY){
          const rectB = document.createElementNS('http://www.w3.org/2000/svg','rect');
          rectB.setAttribute('x', leftX);
          rectB.setAttribute('y', splitY);
          rectB.setAttribute('width', rightX - leftX);
          rectB.setAttribute('height', bottomY - splitY);
          rectB.setAttribute('fill','#ffa756'); rectB.setAttribute('fill-opacity','0.40');
          area.appendChild(rectB);
        }

        const line = document.createElementNS('http://www.w3.org/2000/svg','line');
        line.setAttribute('x1', leftX);  line.setAttribute('x2', rightX);
        line.setAttribute('y1', splitY); line.setAttribute('y2', splitY);
        line.setAttribute('stroke','#ffd7a8'); line.setAttribute('stroke-width','2.2');
        area.appendChild(line);
      }
      svg.appendChild(area);
    }

    // Rectangle border (dot-to-dot span)
    const border = document.createElementNS('http://www.w3.org/2000/svg','rect');
    border.setAttribute('x', pad + rX*dotSpacing);
    border.setAttribute('y', pad + rY*dotSpacing);
    border.setAttribute('width', (rW-1)*dotSpacing);
    border.setAttribute('height',(rH-1)*dotSpacing);
    border.setAttribute('fill','none');
    border.setAttribute('stroke','#56a0ff');
    border.setAttribute('stroke-width','2.4');
    svg.appendChild(border);

    addLabels();
    updateEquation();

    partLabel.textContent = partitionEnabled ? 'ON' : 'OFF';
    splitControls.classList.toggle('dimmed', !partitionEnabled);
    splitDir.disabled = !partitionEnabled;
    splitAt.disabled  = !partitionEnabled;
  }

  function addLabels(){
    const g = document.createElementNS('http://www.w3.org/2000/svg','g');
    g.setAttribute('font-size','12'); g.setAttribute('fill','#e8eef6');

    const tx = pad + (rX*dotSpacing) + ((rW-1)*dotSpacing)/2;
    const ty = pad + rY*dotSpacing - 10;
    const t = document.createElementNS('http://www.w3.org/2000/svg','text');
    t.setAttribute('x', tx); t.setAttribute('y', Math.max(12,ty));
    t.setAttribute('text-anchor','middle'); t.textContent = `${rW}`;
    g.appendChild(t);

    const lx = pad + rX*dotSpacing - 10;
    const ly = pad + (rY*dotSpacing) + ((rH-1)*dotSpacing)/2 + 4;
    const t2 = document.createElementNS('http://www.w3.org/2000/svg','text');
    t2.setAttribute('x', Math.max(10,lx)); t2.setAttribute('y', ly);
    t2.setAttribute('text-anchor','middle'); t2.textContent = `${rH}`;
    g.appendChild(t2);

    if (partitionEnabled){
      if (partDir==='vertical'){
        const leftX   = pad + rX*dotSpacing;
        const splitX  = pad + (rX + sAt)*dotSpacing;
        const rightX  = pad + (rX + (rW-1))*dotSpacing;
        const txA = (leftX + splitX)/2, txB = (splitX + rightX)/2;
        const tA = document.createElementNS('http://www.w3.org/2000/svg','text');
        tA.setAttribute('x', txA); tA.setAttribute('y', Math.max(12,ty-12));
        tA.setAttribute('text-anchor','middle'); tA.textContent = `${sAt}`;
        g.appendChild(tA);
        const b = Math.max(0, rW - sAt);
        if (b>0){
          const tB = document.createElementNS('http://www.w3.org/2000/svg','text');
          tB.setAttribute('x', txB); tB.setAttribute('y', Math.max(12,ty-12));
          tB.setAttribute('text-anchor','middle'); tB.textContent = `${b}`;
          g.appendChild(tB);
        }
      } else {
        const topY    = pad + rY*dotSpacing;
        const splitY  = pad + (rY + sAt)*dotSpacing;
        const bottomY = pad + (rY + (rH-1))*dotSpacing;
        const tyA = (topY + splitY)/2 + 4, tyB = (splitY + bottomY)/2 + 4;
        const tA = document.createElementNS('http://www.w3.org/2000/svg','text');
        tA.setAttribute('x', Math.max(10, (pad + rX*dotSpacing) - 12)); tA.setAttribute('y', tyA);
        tA.setAttribute('text-anchor','middle'); tA.textContent = `${sAt}`;
        g.appendChild(tA);
        const b = Math.max(0, rH - sAt);
        if (b>0){
          const tB = document.createElementNS('http://www.w3.org/2000/svg','text');
          tB.setAttribute('x', Math.max(10, (pad + rX*dotSpacing) - 12)); tB.setAttribute('y', tyB);
          tB.setAttribute('text-anchor','middle'); tB.textContent = `${b}`;
          g.appendChild(tB);
        }
      }
    }
    svg.appendChild(g);
  }

  function updateEquation(){
    const total = rW * rH;
    const fmt = (a,b)=>`${a} × ${b}`;
    if (!partitionEnabled){
      equation.innerHTML = `<div><b>Product:</b> ${fmt(rH,rW)} = <b>${total}</b></div>`;
      return;
    }
    if (partDir==='vertical'){
      const a = sAt, b = rW - sAt;
      equation.innerHTML =
        `<div><b>Product:</b> ${fmt(rH,rW)} = <b>${total}</b></div>` +
        `<div>Partition: ${fmt(rH,rW)} = (${fmt(rH,a)}) + (${fmt(rH,b)}) = ${rH*a} + ${rH*b} = <b>${total}</b></div>`;
    } else {
      const a = sAt, b = rH - sAt;
      equation.innerHTML =
        `<div><b>Product:</b> ${fmt(rH,rW)} = <b>${total}</b></div>` +
        `<div>Partition: ${fmt(rH,rW)} = (${fmt(a,rW)}) + (${fmt(b,rW)}) = ${a*rW} + ${b*rW} = <b>${total}</b></div>`;
    }
  }

  function svgPointFromEvent(e){
    const pt = svg.createSVGPoint(); pt.x = e.clientX; pt.y = e.clientY;
    return pt.matrixTransform(svg.getScreenCTM().inverse());
  }

  svg.addEventListener('pointerdown', (e)=>{
    const p = svgPointFromEvent(e), g = snapGrid(p.x, p.y);
    if (nearSplit(p.x, p.y)){ dragMode = 'moveSplit'; dragData = {}; }
    else if (insideRect(g.c, g.r)){ dragMode = 'moveRect'; dragData = { startC:g.c, startR:g.r, startX:rX, startY:rY }; }
    else { dragMode = 'newRect'; dragData = { startC:g.c, startR:g.r }; }
    svg.setPointerCapture(e.pointerId);
  });

  svg.addEventListener('pointermove', (e)=>{
    if (!dragMode) return;
    const p = svgPointFromEvent(e), g = snapGrid(p.x, p.y);
    if (dragMode==='newRect'){
      const minC=Math.min(dragData.startC,g.c), maxC=Math.max(dragData.startC,g.c);
      const minR=Math.min(dragData.startR,g.r), maxR=Math.max(dragData.startR,g.r);
      rX = clamp(minC,0,cols-1); rY = clamp(minR,0,rows-1);
      rW = clamp((maxC-minC)+1,1,cols-rX); rH = clamp((maxR-minR)+1,1,rows-rY);
      sAt = clamp(sAt, 0, partDir==='vertical'? rW : rH); splitAt.value = sAt; draw();
    } else if (dragMode==='moveRect'){
      const dC=g.c-dragData.startC, dR=g.r-dragData.startR;
      rX = clamp(dragData.startX + dC, 0, cols - rW);
      rY = clamp(dragData.startY + dR, 0, rows - rH);
      draw();
    } else if (dragMode==='moveSplit' && partitionEnabled){
      if (partDir==='vertical'){ sAt = clamp(g.c - rX, 0, rW); }
      else { sAt = clamp(g.r - rY, 0, rH); }
      splitAt.value = sAt; draw();
    }
  });

  window.addEventListener('pointerup', (e)=>{
    dragMode = null; dragData = null;
    if (e.pointerId) try{ svg.releasePointerCapture(e.pointerId); }catch{}
  });

  [gridCols, gridRows].forEach(el=> el.addEventListener('input', draw));
  splitDir.addEventListener('input', ()=>{ sAt = clamp(sAt, 0, splitDir.value==='vertical'? rW : rH); splitAt.value = sAt; draw(); });
  splitAt.addEventListener('input', ()=>{ sAt = +splitAt.value; draw(); });
  partToggle.addEventListener('input', ()=>{ partitionEnabled = partToggle.checked; draw(); });

  btnExample.addEventListener('click', ()=>{
    // 6×7, split 6+1 (vertical)
    rW=7; rH=6; rX=2; rY=2; partDir='vertical'; splitDir.value='vertical'; sAt=6; splitAt.value=6;
    partitionEnabled=true; partToggle.checked=true; draw();
  });
  btnReset.addEventListener('click', ()=>{
    gridCols.value=20; gridRows.value=20; rW=7; rH=6; rX=1; rY=1; partDir='vertical'; splitDir.value='vertical'; sAt=6; splitAt.value=6;
    partitionEnabled=false; partToggle.checked=false; draw();
  });

  btnExport.addEventListener('click', ()=>{
    const serializer=new XMLSerializer();
    const src=serializer.serializeToString(svg);
    const img=new Image();
    const blob=new Blob([src],{type:'image/svg+xml;charset=utf-8'});
    const url=URL.createObjectURL(blob);
    img.onload=function(){
      const canvas=document.createElement('canvas');
      canvas.width=svg.viewBox.baseVal.width; canvas.height=svg.viewBox.baseVal.height;
      const ctx=canvas.getContext('2d');
      ctx.fillStyle='#0a0d11'; ctx.fillRect(0,0,canvas.width,canvas.height);
      ctx.drawImage(img,0,0); URL.revokeObjectURL(url);
      canvas.toBlob((b)=>{ const a=document.createElement('a'); a.download=`partition_${rH}x${rW}.png`; a.href=URL.createObjectURL(b); a.click(); });
    };
    img.src=url;
  });

  sizeSVG(); draw();
})();
</script>
</body>
</html>


