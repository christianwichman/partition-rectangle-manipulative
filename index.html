<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0" />
<title>Consolidated Math Manipulative — Arrays & Partitions</title>
<style>
  :root{
    --bg:#0b0b0b; --fg:#f5f5f5; --muted:#bdbdbd; --accent:#3a86ff; --surface:#161616; --card:#1e1e1e;
    --red:#e74c3c; --white:#fafafa; --blue:#1e90ff; --grid:#2c2c2c; --green:#19c37d;
    --font: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Ubuntu, Cantarell, Noto Sans, Arial, "Apple Color Emoji", "Segoe UI Emoji";
  }
  html, body { height: 100%; }
  body{
    margin:0; background:var(--bg); color:var(--fg); font-family:var(--font);
    display:flex; flex-direction:column; gap:16px; padding:16px; box-sizing:border-box;
  }
  h1{ margin:0 0 8px; font-size:22px; font-weight:700; letter-spacing:.2px; }
  .tabs{ display:flex; gap:8px; }
  .tab-btn{ background:var(--surface); color:var(--fg); border:1px solid #2a2a2a; padding:8px 12px; border-radius:10px; cursor:pointer; }
  .tab-btn[aria-selected="true"]{ outline:2px solid var(--accent); }
  .panel{ display:none; }
  .panel.active{ display:block; }

  /* Cards */
  .card{ background:var(--card); border:1px solid #2a2a2a; border-radius:14px; padding:14px; }

  /* Controls */
  .controls{ display:flex; flex-wrap:wrap; gap:8px; margin-bottom:10px; }
  .btn{ background:var(--surface); color:var(--fg); border:1px solid #2a2a2a; border-radius:10px; padding:8px 12px; cursor:pointer; }
  .btn:active{ transform:translateY(1px); }
  .btn-accent{ outline:2px solid var(--accent); }
  .btn-success{ outline:2px solid var(--green); }
  .switch{ display:inline-flex; align-items:center; gap:6px; }
  .switch input{ accent-color:var(--accent); }
  label{ font-size:14px; color:var(--muted); }
  input[type="text"], input[type="number"]{ background:var(--surface); color:var(--fg); border:1px solid #2a2a2a; border-radius:10px; padding:8px 10px; }

  /* Arrays tool */
  .arrays-wrap{ display:grid; grid-template-columns: repeat(auto-fit, minmax(260px, 1fr)); gap:14px; }
  .array-card{ position:relative; padding:12px; }
  .grid{ display:grid; grid-template-columns: repeat(10, 1fr); gap:6px; }
  .dot{
    width:22px; height:22px; border-radius:50%; display:inline-block; position:relative; cursor:pointer; transition:transform .06s ease-in-out;
    border:1px solid #2f2f2f;
  }
  .dot:hover{ transform:scale(1.06); }
  .dot.red{ background:var(--red); }
  .dot.white{ background:var(--white); }
  .dot.clicked::after{
    content:""; position:absolute; left:50%; top:50%; transform:translate(-50%,-50%);
    width:8px; height:8px; background:var(--blue); border-radius:50%; box-shadow:0 0 0 1px rgba(0,0,0,.35) inset;
  }
  .array-controls{ display:flex; gap:8px; margin-top:10px; flex-wrap:wrap; }

  /* Partition tool */
  .partition-wrap{ display:grid; grid-template-columns: 320px 1fr; gap:16px; align-items:start; }
  @media (max-width: 900px){ .partition-wrap{ grid-template-columns: 1fr; } }
  .canvas-card{ position:relative; }
  #field{ width:100%; height:520px; background:var(--surface); border-radius:12px; border:1px solid #2a2a2a; display:block; }
  .floating-controls{ position:absolute; right:12px; top:12px; display:flex; flex-direction:column; gap:8px; }
  .axis-labels{ display:flex; gap:20px; margin-top:8px; font-size:15px; color:var(--muted); flex-wrap:wrap; }
  .axis-chip{ background:var(--surface); border:1px solid #2a2a2a; border-radius:999px; padding:6px 10px; }
  .note{ color:var(--muted); font-size:13px; }
  .kbd{ font-family:ui-monospace,SFMono-Regular,Menlo,monospace; background:#0e0e0e; border:1px solid #2a2a2a; padding:2px 6px; border-radius:6px; }

  /* Collapsible controls */
  details.controls-collapsible{ background:var(--card); border:1px solid #2a2a2a; border-radius:12px; padding:10px 12px; }
  details.controls-collapsible > summary{ cursor:pointer; font-weight:600; color:var(--muted); }
</style>
</head>
<body>
  <header>
    <h1>Consolidated Math Manipulative</h1>
    <div class="tabs" role="tablist" aria-label="Tools">
      <button class="tab-btn" role="tab" aria-selected="true" data-tab="arrays">Arrays (10×10)</button>
      <button class="tab-btn" role="tab" aria-selected="false" data-tab="partition">Rectangle Partitions</button>
    </div>
  </header>

  <!-- Arrays Panel -->
  <section id="panel-arrays" class="panel active" role="tabpanel" aria-labelledby="Arrays (10×10)">
    <div class="card">
      <div class="controls">
        <button id="addArray" class="btn btn-success">Add 10×10 Array</button>
        <button id="rearrangeAll" class="btn">Rearrange Clicked (each array)</button>
        <button id="clearAllClicks" class="btn">Clear Clicks</button>
      </div>
      <div id="arrays" class="arrays-wrap" aria-live="polite"></div>
      <p class="note">Each array row follows <span class="kbd">5 red</span> then <span class="kbd">5 white</span>, repeating. Click a circle to tag it (blue dot). “Rearrange” groups clicked <strong>reds</strong> first, then clicked <strong>whites</strong>; all remaining unclicked dots keep the 5-red/5-white pattern as closely as possible.</p>
    </div>
  </section>

  <!-- Partition Panel -->
  <section id="panel-partition" class="panel" role="tabpanel" aria-labelledby="Rectangle Partitions">
    <div class="partition-wrap">
      <details class="controls-collapsible" open>
        <summary>Controls</summary>
        <div class="controls">
          <label>Expression (W × H): <input id="expr" type="text" value="6 x 4" aria-label="Rectangle expression"></label>
          <button id="applyExpr" class="btn btn-success">Set Rectangle</button>
        </div>
        <div class="controls">
          <span class="switch"><input id="toggleTheme" type="checkbox"/> <label for="toggleTheme">Black on White</label></span>
          <span class="switch"><input id="toggleDots" type="checkbox" checked/> <label for="toggleDots">Show Dots</label></span>
          <button id="toggleAreas" class="btn">Toggle Areas</button>
          <button id="resetPartitions" class="btn">Clear Partitions</button>
        </div>
        <label>Write expression for the rectangle: <input id="exprLabel" type="text" value="6 × 4" aria-label="Expression label"></label>
        <p class="note" style="margin-top:6px">Tip: Turn on <em>Partition Mode</em> (button on the field), then <b>click and drag</b> inside the rectangle to place a vertical or horizontal cut; your drag direction decides orientation. A preview line shows where the cut will land.</p>
      </details>

      <div class="card canvas-card">
        <canvas id="field" width="1000" height="520" aria-label="Partition field"></canvas>
        <div class="floating-controls">
          <button id="partitionMode" class="btn">Partition Mode: OFF</button>
          <button id="showProduct" class="btn">Show W×H</button>
        </div>
        <div id="axis" class="axis-labels" aria-live="polite"></div>
      </div>
    </div>
  </section>

  <script>
    /* ----------------------- Tabs ----------------------- */
    document.querySelectorAll('.tab-btn').forEach(btn=>{
      btn.addEventListener('click',()=>{
        document.querySelectorAll('.tab-btn').forEach(b=>b.setAttribute('aria-selected','false'));
        btn.setAttribute('aria-selected','true');
        const tab=btn.dataset.tab;
        document.querySelectorAll('.panel').forEach(p=>p.classList.remove('active'));
        document.getElementById('panel-'+tab).classList.add('active');
      });
    });

    /* --------------------- Arrays Tool --------------------- */
    const arraysEl = document.getElementById('arrays');

    function baseColorAt(index){ const col = index % 10; return col < 5 ? 'red' : 'white'; }

    function makeArrayCard(){
      const card = document.createElement('div'); card.className = 'card array-card';
      const grid = document.createElement('div'); grid.className = 'grid';
      const state = [];
      for(let i=0;i<100;i++){
        const color = baseColorAt(i);
        state.push({ color, clicked:false });
        const dot = document.createElement('div'); dot.className = `dot ${color}`;
        dot.addEventListener('click', ()=>{ state[i].clicked = !state[i].clicked; dot.classList.toggle('clicked', state[i].clicked); });
        grid.appendChild(dot);
      }
      const ctrls = document.createElement('div'); ctrls.className = 'array-controls';
      const rearr = document.createElement('button'); rearr.className='btn'; rearr.textContent='Rearrange Clicked';
      rearr.addEventListener('click', ()=> rearrangeArray(grid, state));
      const clear = document.createElement('button'); clear.className='btn'; clear.textContent='Clear Clicks';
      clear.addEventListener('click', ()=>{ state.forEach((s,idx)=>{ if(s.clicked){ s.clicked=false; grid.children[idx].classList.remove('clicked'); } }); });
      ctrls.appendChild(rearr); ctrls.appendChild(clear);
      card.appendChild(grid); card.appendChild(ctrls);
      return card;
    }

    function renderArray(grid, state){ for(let i=0;i<100;i++){ const el=grid.children[i]; el.className = `dot ${state[i].color}`; el.classList.toggle('clicked', !!state[i].clicked); } }

    function rearrangeArray(grid, state){
      const clickedRed = state.filter(s=>s.clicked && s.color==='red');
      const clickedWhite = state.filter(s=>s.clicked && s.color==='white');
      const unclicked = state.filter(s=>!s.clicked);
      const patterned = []; let toggle5 = true, remaining = unclicked.length;
      while(remaining>0){ const take=Math.min(5,remaining); for(let i=0;i<take;i++) patterned.push({color:toggle5?'red':'white', clicked:false}); toggle5=!toggle5; remaining-=take; }
      const combined = [...clickedRed, ...clickedWhite, ...patterned];
      while(combined.length<100) combined.push({color:'white', clicked:false}); combined.length=100;
      for(let i=0;i<100;i++) state[i] = {...combined[i]};
      renderArray(grid, state);
    }

    document.getElementById('addArray').addEventListener('click', ()=> arraysEl.appendChild(makeArrayCard()));
    document.getElementById('rearrangeAll').addEventListener('click', ()=>{
      document.querySelectorAll('.array-card').forEach(card=>{
        const grid = card.querySelector('.grid');
        const state = Array.from(grid.children).map(ch=>({ color: ch.classList.contains('red')?'red':'white', clicked: ch.classList.contains('clicked') }));
        rearrangeArray(grid, state);
      });
    });
    document.getElementById('clearAllClicks').addEventListener('click', ()=>{ document.querySelectorAll('.array-card .dot.clicked').forEach(d=>d.classList.remove('clicked')); });
    arraysEl.appendChild(makeArrayCard());

    /* ------------------- Partition Tool ------------------- */
    const field = document.getElementById('field');
    const ctx = field.getContext('2d');
    let W=6, H=4; // cells
    let showDots = true;
    let lightTheme = false; // false: white on black; true: black on white
    let showAreas = false;
    let showProductOnly = false;

    // Partition mode (toggle on the canvas)
    let partitionMode = false; // armed when true
    let dragActive = false;    // dragging within rect to decide orientation
    let dragStart = null;      // {x,y}
    let previewCut = null;     // {type:'v'|'h', index:number}

    const verticalCuts = new Set();   // 1..W-1
    const horizontalCuts = new Set(); // 1..H-1

    function parseExpr(text){
      const m = text.toLowerCase().replace(/×/g,'x').match(/(\\d+)\\s*[x\\*]\\s*(\\d+)/);
      return m ? {w: Math.max(1, parseInt(m[1],10)), h: Math.max(1, parseInt(m[2],10))} : null;
    }

    function cellGeom(){
      const pad = 28;
      const width = field.width - pad*2;
      const height = field.height - pad*2;
      const cw = width / W;
      const ch = height / H;
      return { pad, width, height, cw, ch };
    }

    function insideRectPx(x,y){
      const {pad,width,height}=cellGeom();
      return x>=pad && x<=pad+width && y>=pad && y<=pad+height;
    }

    function draw(){
      ctx.clearRect(0,0,field.width, field.height);
      ctx.fillStyle = lightTheme ? '#ffffff' : '#0f0f10';
      ctx.fillRect(0,0,field.width, field.height);

      const {pad, width, height, cw, ch} = cellGeom();

      // Border
      ctx.strokeStyle = lightTheme ? '#c9c9c9' : '#2a2a2a';
      ctx.lineWidth = 2;
      ctx.strokeRect(pad, pad, width, height);

      // Dots
      if(showDots){
        ctx.fillStyle = lightTheme ? '#101010' : '#f0f0f0';
        for(let r=0;r<=H;r++){
          for(let c=0;c<=W;c++){
            const x = pad + c*cw;
            const y = pad + r*ch;
            ctx.beginPath();
            ctx.arc(x, y, 2, 0, Math.PI*2);
            ctx.fill();
          }
        }
      }

      // Grid lines
      ctx.strokeStyle = lightTheme ? '#d8d8d8' : '#262626';
      ctx.lineWidth = 1;
      for(let r=1;r<H;r++){
        const y = pad + r*ch; ctx.beginPath(); ctx.moveTo(pad, y); ctx.lineTo(pad+width, y); ctx.stroke();
      }
      for(let c=1;c<W;c++){
        const x = pad + c*cw; ctx.beginPath(); ctx.moveTo(x, pad); ctx.lineTo(x, pad+height); ctx.stroke();
      }

      // Areas overlay
      if(showAreas){
        const v=[0,...Array.from(verticalCuts).sort((a,b)=>a-b),W];
        const h=[0,...Array.from(horizontalCuts).sort((a,b)=>a-b),H];
        ctx.fillStyle = lightTheme ? '#111' : '#eaeaea';
        ctx.font = '600 16px ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto';
        ctx.textAlign='center'; ctx.textBaseline='middle';
        for(let i=0;i<h.length-1;i++){
          for(let j=0;j<v.length-1;j++){
            const w=v[j+1]-v[j], hh=h[i+1]-h[i];
            const x = pad + (v[j]+w/2)*cw;
            const y = pad + (h[i]+hh/2)*ch;
            ctx.fillText(`${w}×${hh} = ${w*hh}`, x, y);
          }
        }
      }

      // Partitions
      ctx.strokeStyle = '#1e90ff';
      ctx.lineWidth = 3;
      horizontalCuts.forEach(r=>{ const y=pad+r*ch; ctx.beginPath(); ctx.moveTo(pad, y); ctx.lineTo(pad+width, y); ctx.stroke(); });
      verticalCuts.forEach(c=>{ const x=pad+c*cw; ctx.beginPath(); ctx.moveTo(x, pad); ctx.lineTo(x, pad+height); ctx.stroke(); });

      // Preview partition while dragging in partition mode
      if(previewCut){
        ctx.save();
        ctx.strokeStyle = '#1e90ff88';
        ctx.lineWidth=2;
        if(previewCut.type==='v'){
          const x=pad+previewCut.index*cw; ctx.beginPath(); ctx.moveTo(x,pad); ctx.lineTo(x,pad+height); ctx.stroke();
        } else {
          const y=pad+previewCut.index*ch; ctx.beginPath(); ctx.moveTo(pad,y); ctx.lineTo(pad+width,y); ctx.stroke();
        }
        ctx.restore();
      }

      // Axis segment chips (only show parts, not totals)
      renderAxisChips();

      // Product label
      if(showProductOnly){
        ctx.fillStyle = lightTheme ? '#111' : '#eaeaea';
        ctx.font = '700 18px ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto';
        ctx.textAlign='left'; ctx.textBaseline='alphabetic';
        ctx.fillText(`Product: ${W}×${H} = ${W*H}`, 12, field.height-12);
      }
    }

    function renderAxisChips(){
      const axis = document.getElementById('axis');
      axis.innerHTML = '';
      const v=[0,...Array.from(verticalCuts).sort((a,b)=>a-b),W];
      const h=[0,...Array.from(horizontalCuts).sort((a,b)=>a-b),H];
      const wParts=[], hParts=[];
      for(let i=0;i<v.length-1;i++) wParts.push(v[i+1]-v[i]);
      for(let i=0;i<h.length-1;i++) hParts.push(h[i+1]-h[i]);
      if(verticalCuts.size>0){
        const wEl=document.createElement('div'); wEl.className='axis-chip';
        wEl.textContent=`Width parts: ${wParts.join(' + ')}`; axis.appendChild(wEl);
      }
      if(horizontalCuts.size>0){
        const hEl=document.createElement('div'); hEl.className='axis-chip';
        hEl.textContent=`Height parts: ${hParts.join(' + ')}`; axis.appendChild(hEl);
      }
    }

    function setRectangle(w,h){
      W=w; H=h;
      verticalCuts.clear(); horizontalCuts.clear();
      showAreas=false; showProductOnly=false; previewCut=null; draw();
    }

    function nearestCutFromPoint(x,y){
      const {pad,width,height,cw,ch}=cellGeom();
      if(x<pad||x>pad+width||y<pad||y>pad+height) return null;
      const colPos=(x-pad)/cw, rowPos=(y-pad)/ch;
      const colNearest=Math.round(colPos), rowNearest=Math.round(rowPos);
      const dx=Math.abs(colPos-colNearest)*cw, dy=Math.abs(rowPos-rowNearest)*ch;
      if(dx<dy){ if(colNearest>0&&colNearest<W) return {type:'v',index:colNearest}; }
      else{ if(rowNearest>0&&rowNearest<H) return {type:'h',index:rowNearest}; }
      return null;
    }

    // --- Mouse interactions for partition mode ---
    function getCanvasXY(e){
      const rect=field.getBoundingClientRect();
      const x=(e.clientX-rect.left)*(field.width/rect.width);
      const y=(e.clientY-rect.top)*(field.height/rect.height);
      return {x,y};
    }

    field.addEventListener('mousedown', (e)=>{
      if(!partitionMode) return;
      const {x,y}=getCanvasXY(e);
      if(!insideRectPx(x,y)) return;
      dragActive=true; dragStart={x,y}; previewCut=null;
    });

    field.addEventListener('mousemove', (e)=>{
      if(!partitionMode || !dragActive) return;
      const {x,y}=getCanvasXY(e);
      const dx=x-dragStart.x, dy=y-dragStart.y;
      if(Math.hypot(dx,dy)<3){ previewCut=null; draw(); return; } // ignore tiny moves
      const preferV = Math.abs(dx) > Math.abs(dy);
      const cut = nearestCutFromPoint(x,y);
      if(!cut){ previewCut=null; draw(); return; }
      if(preferV && cut.type==='h'){
        const {pad,cw}=cellGeom(); const colPos=(x-pad)/cw; const colNearest=Math.round(colPos);
        previewCut = (colNearest>0 && colNearest<W) ? {type:'v', index:colNearest} : null;
      } else if(!preferV && cut.type==='v'){
        const {pad,ch}=cellGeom(); const rowPos=(y-pad)/ch; const rowNearest=Math.round(rowPos);
        previewCut = (rowNearest>0 && rowNearest<H) ? {type:'h', index:rowNearest} : null;
      } else {
        previewCut = cut;
      }
      draw();
    });

    window.addEventListener('mouseup', ()=>{
      if(!partitionMode || !dragActive) return;
      dragActive=false;
      if(previewCut){
        if(previewCut.type==='v') verticalCuts.add(previewCut.index);
        else horizontalCuts.add(previewCut.index);
        previewCut=null;
        draw();
      }
    });

    // Controls
    document.getElementById('applyExpr').addEventListener('click', ()=>{
      const parsed = parseExpr(document.getElementById('expr').value);
      if(parsed){
        setRectangle(parsed.w, parsed.h);
        document.getElementById('exprLabel').value = `${parsed.w} × ${parsed.h}`;
      }
    });
    document.getElementById('toggleDots').addEventListener('change', (e)=>{ showDots = e.target.checked; draw(); });
    document.getElementById('toggleTheme').addEventListener('change', (e)=>{ lightTheme = e.target.checked; draw(); });

    const partitionBtn = document.getElementById('partitionMode');
    partitionBtn.addEventListener('click', ()=>{
      partitionMode = !partitionMode;
      partitionBtn.textContent = `Partition Mode: ${partitionMode? 'ON':'OFF'}`;
      partitionBtn.classList.toggle('btn-accent', partitionMode);
    });

    document.getElementById('resetPartitions').addEventListener('click', ()=>{
      verticalCuts.clear(); horizontalCuts.clear(); previewCut=null; draw();
    });
    document.getElementById('toggleAreas').addEventListener('click', ()=>{
      showAreas = !showAreas; draw();
    });
    document.getElementById('showProduct').addEventListener('click', ()=>{
      showProductOnly = !showProductOnly; draw();
    });

    // Initial render
    draw();
  </script>
</body>
</html>
